\documentclass[a4paper]{article}
\usepackage[spanish,activeacute]{babel}
\usepackage[ansinew]{inputenc}
% Anda fen'omeno mientras codifiquemos el archivo como ansi.
\usepackage{graphicx}
\usepackage[left=2cm,right=2cm]{geometry}
\usepackage{ulem} %Para tachar cosas
%\usepackage{epigraph}
\usepackage{listings}
\usepackage{html}
\usepackage[colorlinks=true]{hyperref}
\parindent = 0 pt
\parskip = 11 pt

\newcommand{\haskell}{\textsl{Haskell}}
\newcommand{\hpage}{\textbf{\textsl{$\lambda$Page}}}

\begin{document}

    \thispagestyle{empty}
    \begin{center}
	    {\Large Tesis de Licenciatura}\\[1em]
	    {\huge \textbf{$\lambda$Page}}\\[0.5em]
	    {\large \textit{Un bloc de notas para desarrolladores Haskell}}\\[1em]
	    \par\vspace{\stretch{1}}
	    {\large Departamento de Computaci\'on}\\[0.5em]
	    {\large Facultad de Ciencias Exactas y Naturales}\\[0.5em]
	    {\large Universidad de Buenos Aires}
	    \par\vspace{\stretch{1}}
	    \begin{figure}[h]
	        \begin{center}
	        \includegraphics[width=40mm]{logoUba}
	        \end{center}
	    \end{figure}
	    {\Large \textbf{Alumno}}\\[0.8em]
	    {\Large Fernando Benavides (LU 470/01)} \par
	    {\Large greenmellon@gmail.com} \par
	    \par\vspace{\stretch{1}}
	    {\Large \textbf{Directores}}\\[0.8em]
	    {\Large Dr. Diego Garbervetsky} \par
	    {\Large Lic. Daniel Gor'in} \par
	    \par\vspace{\stretch{2}}
         {\Large \textbf{Abstract}}\\[0.5em]
    \end{center}
    El presente documento describe una herramienta para desarrolladores \haskell\ que pretende facilitar la tarea de ``debuggear'', analizar y entender c'odigo, llamada \hpage.  Con ella el usuario puede manipular ``p'aginas'' de texto libre que contengan expresiones \haskell, intentar interpretar 'estas expresiones independientemente y analizar los resultados obtenidos.
    \vspace*{\stretch{3}}
    \newpage

\tableofcontents
\newpage

\section{Introducci'on}
\subsection{Motivaci'on}
\paragraph{}Actualmente estamos presenciando un importante cambio en el desarrollo de sistemas, gracias al 'exito de proyectos como \htmladdnormallinkfoot{CouchDB}{http://couchdb.apache.org}, \htmladdnormallinkfoot{ejabberd}{http://www.ejabberd.im} y el chat de \htmladdnormallinkfoot{Facebook}{http://www.facebook.com}, todos ellos desarrollados utilizando lenguajes del paradigma funcional.
\paragraph{}Ejemplos de 'estos lenguajes de programaci'on, como \htmladdnormallinkfoot{Haskell}{http://www.haskell.org} o \htmladdnormallinkfoot{Erlang}{http://www.erlang.org}, demuestran ser maduros, confiables y presentan claras ventajas en comparaci'on con los lenguajes tradicionales del paradigma imperativo.  Sin embargo, los desarrolladores que deciden realizar el cambio de paradigma se encuentran con el problema de la escasez de ciertas herramientas que les permitan realizar su trabajo m'as eficientemente.  Por el contrario, 'estas herramientas abundan en el desarrollo de proyectos utilizando lenguajes orientados a objetos.  En particular, nuestro foco de atenci'on se centra sobre aquellas herramientas que permiten realizar \textsl{debugging} y \textsl{entendimiento} de c'odigo a trav'es de \textsl{``micro-testing''}\footnote{Enti'endase ``micro-testing'' como la tarea de realizar tests eventuales para entender o evaluar alg'un aspecto de un programa} .
\paragraph{}Los desarrolladores Haskell cuentan actualmente con dos herramientas de este tipo:
\begin{description}
	\item[\htmladdnormallinkfoot{GHCi}{http://www.haskell.org/ghc/docs/latest/html/users\_guide/ghci.html}]
		La consola que provee \htmladdnormallinkfoot{GHC}{http://www.haskell.org/ghc} permite a los desarrolladores evaluar expresiones, verificar su tipo o su clase.  Cuenta tambi'en con un \htmladdnormallinkfoot{mecanismo de debugging}{http://www.haskell.org/ghc/docs/6.10-latest/html/users\_guide/ghci-debugger.html} integrado que permite realizar la evaluaci'on de expresiones paso a paso.  Pese a ser la herramienta m'as utilizada por los desarrolladores, \textit{GHCi} tiene varias limitaciones.  En particular:
		\begin{itemize}
			\item No permite editar m'as de una expresi'on a la vez
			\item No permite intercalar expresiones con definiciones
			\item	Si bien permite utilizar definiciones, 'estas se pierden al recargar m'odulos
			\item No es sencillo utilizar en una sesi'on las definiciones y/o expresiones creadas en sesiones anteriores
		\end{itemize}
	\item[\htmladdnormallinkfoot{Hat}{http://www.haskell.org/hat}]
		Un herramienta para realizar seguimiento a nivel de c'odigo fuente.  A trav'es de la generaci'on de trazas de ejecuci'on, \textit{Hat} ayuda a localizar errores en los programas y es 'util para entender su funcionamiento.  Sin embargo, por estar basado en la generaci'on de trazas, requiere la compilaci'on y ejecuci'on de un programa para poder utilizarlo y esto no siempre es c'omodo para el desarrollador que puede querer simplemente analizar una expresi'on particular que incluso quiz'a no compile a'un.  Adem'as, su mantenimiento activo parece haber cesado hace m'as de un a'no y en su p'agina se observa una importante lista de \htmladdnormallinkfoot{problemas conocidos}{http://www.haskell.org/hat/bugs.html} y \htmladdnormallinkfoot{caracter'isticas deseadas}{http://www.haskell.org/hat/bugs.html}.  
\end{description}

%%------------------------------------------------------------------------------------------------------------------------------
\subsection{Trabajos Relacionados}
\paragraph{}En el mundo de la programaci'on orientada a objetos podemos encontrar herramientas de este tipo, como \htmladdnormallinkfoot{Java Scrapbook Pages}{http://help.eclipse.org/help33/index.jsp?topic=/org.eclipse.jdt.doc.user/reference/ref-34.htm} para \htmladdnormallinkfoot{Java}{http://www.java.com} y \htmladdnormallinkfoot{Workspace}{http://wiki.squeak.org/squeak/1934} para \htmladdnormallinkfoot{SmallTalk}{http://www.smalltalk.org}.  Utilizando estos aplicativos, los desarrolladores pueden introducir peque'nas porciones de c'odigo, ejecutarlas y luego inspeccionar y analizar los resultados obtenidos.  Un concepto compartido por ambas herramientas es el de presentar ``p'aginas'' de texto en las que varias expresiones pueden intercalarse con partes de texto libre y permitir al desarrollador intentar evaluar s'olo una porci'on de todo lo escrito.  Estas p'aginas pueden ser guardardas y luego recuperadas de modo de poder analizar nuevamente las mismas expresiones.  Adem'as permiten crear objetos (lo que para los lenguajes funcionales equivaldr'ia a definir expresiones) locales a la p'agina en uso y utilizarlos en ella.
\paragraph{}Dentro del paradigma funcional, con un enfoque similar, aunque un poco m'as orientado a la presentaci'on y visualizaci'on de documentos, \htmladdnormallinkfoot{Keith Hanna}{http://www.cs.kent.ac.uk/people/staff/fkh/} de la Universidad de Kent, ha desarrollado \htmladdnormallinkfoot{Vital}{http://www.cs.kent.ac.uk/projects/vital/}.  \textsl{Vital} es una implementaci'on de un entorno de visualizaci'on de documentos para \haskell.  Pretende presentar \haskell\ de una manera apropiada para usuarios finales en areas de aplicaci'on como la ingenier'ia, las matem'aticas o las finanzas.  Dentro de esta herramienta, los m'odulos \haskell\ son presentados como documentos en los que pueden visualizarse los valores que en ellos se definen directamente en el lugar en el que aparecen, ya sea de modo textual o gr'afico (como ``vistas''). 

%%------------------------------------------------------------------------------------------------------------------------------
\subsection{\hpage}
\paragraph{} \htmladdnormallinkfoot{\hpage}{http://haskell.hpage.com} se presenta como una herramienta  similar al Workspace de \textit{Smalltalk}, que permite a los desarrolladores trabajar con documentos de texto libre que incluyan expresiones y definiciones.  \hpage\ es capaz de identificar las expresiones y definiciones v'alidas y permite al desarrollador inspeccionarlas, evaluarlas, conocer su tipo y su clase.
\subparagraph{}En el esp'iritu de las herramientas provistas por la comunidad de desarrolladores \haskell, \hpage\ se integra con \htmladdnormallinkfoot{Cabal}{http://www.haskell.org/cabal} y \htmladdnormallinkfoot{Hayoo!}{http://holumbus.fh-wedel.de/hayoo} y se encuentra ya disponible en \htmladdnormallinkfoot{HackageDB}{http://hackage.haskell.org/package/hpage}.
\subparagraph{}\hpage\ presenta una interfaz simple e intuitiva, desarrollada utilizando \htmladdnormallinkfoot{wxHaskell}{http://haskell.org/haskellwiki/WxHaskell}, lo que lo convierte en un sistema multiplataforma.
\subparagraph{}Por ser una herramienta desarrollada con \haskell\ para \haskell, \hpage\ se diferencia de sus pares del mundo de objetos, al aprovechar conceptos claves como son el tipado fuerte (que permite detectar errores de tipo velozmente, evitando el costo de evaluar expresiones complejas) y la evaluaci'on perezosa (que permite evaluar expresiones infinitas e ir exhibiendo resultados progresivamente).
\subparagraph{}A diferencia de \textsl{GHCi} que es una herramienta ``de consola'', \hpage\ permite visualizar resultados de manera m'as din'amica, permitiendo que errores intermedios, detectados durante la evaluaci'on de una expresi'on no impidan continuar con la misma hasta llegar a un resultado m'as completo.
\subparagraph{}\hpage\ se encuentra desarrollado utilizando \htmladdnormallinkfoot{\textsl{eprocess}}{http://hackage.haskell.org/package/eprocess}, una librer'ia que facilita el manejo de ``threads'' en un estilo similar al de los procesos \textsl{Erlang}.  Gracias al uso de esta librer'ia, \hpage\ puede realizar tareas en paralelo y por lo tanto permitir al usuario continuar editando los documentos en los que est'a trabajando mientras espera que se eval'ue una expresi'on e incluso cancelar una evaluaci'on conservando la porci'on del resultado obtenida hasta ese momento.  Tambi'en gracias al uso de \textsl{eprocess}, \hpage\ permite detectar c'alculos infinitos (o m'as precisamente, c'alculos que demoran demasiado) e informar sobre este hecho al usuario para que ya no siga esperando indefinidamente el resultado de la evaluaci'on solicitada.
\newpage

\section{Tutorial - Descubriendo \hpage}
\subsection{Instalaci'on}
\paragraph{}Para instalar \hpage\ en \textsl{OSX} o \textsl{Windows}, se proveen instaladores en el sitio web de \hpage, sin embargo,como se ha dicho, \hpage\ se encuentra en \textsl{HackageDB} y por lo tanto el modo oficial de instalarlo es utilizando \textsl{Cabal}, con el siguiente comando:
\lstset{language=sh, frame=single, tabsize=2}
\begin{lstlisting}
$ cabal install hpage
\end{lstlisting}
\subparagraph{}Sin embargo, para ello, previamente se deben satisfacer las siguientes dependencias:
\begin{description}
	\item[\htmladdnormallinkfoot{wxWidgets 2.8.10+}{http://www.wxwidgets.org/downloads/}] El framework de desarrollo para interfaces de usuario que utiliza \textsl{wxHaskell}.  Debe ser instalado con los m'odulos unicode, cmdline, config, log, stl, richtext y clipboard, al menos y con el m'odulo odbc desactivado.
	\item[\htmladdnormallinkfoot{Haskell Platform}{http://hackage.haskell.org/platform/}] Una distribuci'on de \haskell\ que incluye todo lo necesario para compilar e instalar programas desarrollados en este lenguaje (de particular inter'es para \hpage: GHC y happy).
\end{description}
\subsubsection{Windows}Para el correcto funcionamiento de \hpage\ los usuarios de \textsl{Windows XP} deben instalar el \htmladdnormallinkfoot{C++ 2008 SP1}{http://www.microsoft.com/downloads/details.aspx?familyid=A5C84275-3B97-4AB7-A40D-3802B2AF5FC2}.
\subsubsection{Linux}En algunas distribuciones de Linux es conveniente, adem'as de la instalaci'on de \textsl{Haskell Platform} instalar las librer'ias de \textit{Monad Transformers} ejecutando, por ejemplo:
\begin{lstlisting}
$ sudo aptitude install libghc6-mtl-dev libghc6-mtl-doc
\end{lstlisting}
\newpage
\subsection{QuickStart}TODO: Tutorial donde se noten las features de \hpage
\newpage

\section{Desarrollo - ?`C'omo se hizo \hpage?}
\subsection{Arquitectura General}
\paragraph{}Las principales decisiones de arquitectura que se tomaron durante el desarrollo de \hpage\ tuvieron como principales motivaciones los siguientes requerimientos:
\begin{description}
\item[Conexi'on con GHC] \hpage\ deb'ia conectarse con el motor de GHC a trav'es de su API de modo de poder detectar e interpretar expresiones.  Para ello se utiliz'o \htmladdnormallinkfoot{hint}{http://projects.haskell.org/hint}
\item[Paralelismo] \hpage\ deb'ia permitir al usuario editar sus documentos mientras esperaba el resultado de la evaluaci'on de alguna expresi'on.  Para ello se cre'o \textsl{eprocess} y se implement'o un modelo de procesos utiliz'andolo.
\item[Errores Controlados] \hpage\ no deb'ia fallar si la evaluaci'on de una expresi'on fallaba.  M'as a'un, tambi'en deb'ia detectar posibles evaluaciones infinitas e informar estas situaciones al usuario
\end{description}
\begin{figure}[htbp]
	\begin{center}
        	\fbox{\includegraphics[]{architecture}}
		\caption{Arquitectura de \hpage}
		\label{arq1}
	\end{center}
\end{figure}
\subparagraph{}Teniendo en cuenta estos requerimientos, la arquitectura resultante puede ser descripta con el diagrama de la figura \ref{arq1}.  Esta figura presenta el estado del sistema en un instante dado.  Cada bloque representan un proceso o ``thread'' en ejecuci'on.  Cada uno de estos procesos se ejecuta dentro del entorno de una m'onada, la cual se encuentra identificada en la esquina superior derecha del bloque.  En el diagrama podemos identificar los siguientes componentes:
\begin{description}
	\item[UI Manager] Este es el thread que inicia el programa, genera y administra la interfaz del usuario utilizando las herramientas provistas por \textsl{wxHaskell}.  En este thread se mantiene el estado visual de la aplicaci'on: el estado de los controles, la 'ultima b'usqueda realizada, etc.
	\item[HPage Server] Este proceso, iniciado por el \textbf{UI Manager}, es el que comunica a la interfaz del usuario con la m'aquina virtual de GHC, a trav'es del \textbf{Hint Server}, captura sus errores y lo reinicia en caso de ser necesario.  En este proceso se mantiene el estado general de la aplicaci'on: sus p'aginas, expresiones, paquetes y m'odulos cargados, etc.
	\item[Hint Server] Este proceso, iniciado por el \textbf{HPage Server}, mantiene una conexi'on con la m'aquina virtual de GHC (a la cual se muestra en la figura conectado a trav'es de una l'inea de puntos)
	\item[Char Filler] Este proceso, iniciado por el \textbf{UI Manager} cumple una muy sencilla funci'on: utilizando los procedimientos de env'io y recepci'on de mensajes provistos por \textsl{eprocess}, espera recibir un caracter (o sea, una expresi'on de tipo Char), para luego evaluarlo y enviar como respuesta su valor en forma normal.
	\item[Value Filler] Estos procesos, iniciados por el \textbf{UI Manager} ante cada evaluaci'on solicitada por el usuario son los encargados de procesar el resultado obtenido del \textbf{HPage Server}. Cabe recordar aqu'i que \haskell\ trabaja con evaluaci'on ``lazy'', por lo cual el resultado obtenido no ha sido a'un completamente procesado.  Cada \textbf{Value Filler} se encarga de evaluar un resultado y mostrarlo por pantalla, para ello env'ia y recibe mensajes del \textbf{Char Filler} a fin de procesar cada caracter a mostrar.
	\item[Runaway Killer] Este thread, creado utilizando la clase \textsl{TimerEx} provista por \textsl{wxHaskell}, es iniciado por cada \textbf{Value Filler} al momento de enviar un nuevo caracter al \textbf{Char Filler}.  El objetivo del \textbf{Runaway Killer} es el de detectar prorcesamiento ``posiblemente'' infinito.  B'asicamente, pasado un segundo de procesamiento, reinicia el \textbf{Char Filler} e informa al \textbf{Value Filler} que lo inici'o que el caracter que se esperaba procesar ha demorado demasiado y podr'ia desencadenar una evaluaci'on infinita.
\end{description}
\paragraph{}Para un mayor detalle, la figura \ref{seq1} nos muestra un diagrama de secuencia correspondiente a un proceso de evaluaci'on.  Para poder brindar un ejemplo completo, hemos ``fabricado'' un tipo que responde al siguiente c'odigo:
\lstset{language=haskell, frame=single, tabsize=4}
\begin{lstlisting}
data WithIfiniteChar = WICinstance Show WithIfiniteChar where    show WIC = ['c', head . show $ length [1..]]
\end{lstlisting}
\subparagraph{}Como puede observarse, al intentar mostrar la expresi'on \texttt{WIC}, \hpage\ se encontrar'a con una cadena cuyo segundo caracter no puede computar pues requiere un c'alculo infinito, en la figura representamos este caracter con la letra $\Omega$.  All'i es donde entra en acci'on el \textbf{Runaway Killer} para informar esta situaci'on al usuario.
\begin{figure}[htbp]
	\begin{center}
        	\fbox{\includegraphics[width=\textwidth]{sequence}}
		\caption{Secuencia de Evaluaci'on de ``WIC''}
		\label{seq1}
	\end{center}
\end{figure}

\subsection{Dise'no} TODO: Contar las decisiones que tomamos y por qu'e
\subsection{Implementaci'on} TODO: Detalles generales de implementaci'on
\subsubsection{wxHaskell}TODO: Pros y contras y workarounds
\subsubsection{Bottoms}TODO: C'omo manejamos los bottoms en el resultado?
\subsubsection{Threads}TODO: C'omo manejamos los threads para la GUI y la VM?
\subsubsection{hint}TODO: C'omo utilizamos hint para conectarnos con la VM y el tema de que es \textsl{lazy}
\subsection{Problemas Resueltos}
\subsubsection{Un Editor de Texto en Haskell}TODO: wxhNotepad
\subsubsection{Multithreading en GHC}TODO: ?`C'omo simular multhreading cuando GHC no es multithread?
TODO: Otros

\section{Resultados}
\subsection{Objetivos Alcanzados}TODO: ?`Qu'e se puede hacer ahora que existe \hpage?
\subsection{Trabajo a Realizar} TODO: Future Work

% As'i se pone c'odigo...
%\lstset{language=C++, frame=single, tabsize=2}
%\begin{lstlisting}
%#include <utility>#include <assert.h>#include <iostream>#include "float_T.h"using namespace std;float_T::float_T() {}float_T::float_T(TIPO_DATO x, unsigned int mantisa){    original= x;    mantisaReal = mantisa;    setValor(x);}TIPO_DATO float_T::getValor(){    return deMantisa;}void float_T::setValor(TIPO_DATO numero){    int mantisa = mantisaReal;    assert(! (mantisa > MAX_MANTISA) );    unsigned char    mascara[CANT_BYTES];        for( int k = CANT_BYTES - 1; k >= 0; k-- )        if (CANT_BYTES - k <= BYTES_EXP)            mascara[k] = 0xFF;        else            mascara[k] = 0x00;        int i = CANT_BYTES - BYTES_EXP - 1;    while(mantisa >= 8)    {        mascara[i] = 0xFF;        mantisa    -= 8;        i--;    }    unsigned char quito = 0x80;    while( mantisa > 0 )    {        mascara[i] += quito;        quito = quito / 2;        mantisa--;    }    for(unsigned int j = 0; j < CANT_BYTES; j++ )    {        quito                = ((unsigned char *)&numero)[j];        mascara[j]    &= quito;    }        deMantisa= *((TIPO_DATO *)&mascara);}unsigned int float_T::getMantisa(){    return mantisaReal;}TIPO_DATO float_T::getOriginal(){    return original;}void float_T::setOriginal(TIPO_DATO y){    original= y;    }
%\end{lstlisting}

% As'i se ponen ep'igrafes...
%\begin{epigraphs}
%    \qitem{bla bla bla}{Alguien}
%    \qitem{jajaja}{Alguien Chistoso}
%\end{epigraphs}
\end{document}