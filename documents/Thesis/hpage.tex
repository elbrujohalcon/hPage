\documentclass[a4paper]{article}
\usepackage[spanish,activeacute]{babel}
\usepackage[applemac]{inputenc}
\usepackage{cite}
\usepackage{graphicx}
\usepackage[left=2cm,right=2cm]{geometry}
\usepackage{ulem} %Para tachar cosas
\usepackage{epigraph}
\usepackage{enumerate}
\usepackage{listings}
\usepackage{html}
\usepackage{booktabs}
\usepackage[colorlinks=true]{hyperref}
\bibliographystyle{plainurl}
\parindent = 0 pt
\parskip = 11 pt

\newcommand{\haskell}{\textsl{Haskell}}
\newcommand{\hpage}{\textbf{\textsl{$\lambda$Page}}}
\newcommand{\cabal}{\textsl{Cabal}}

\begin{document}

    \thispagestyle{empty}
    \begin{center}
	    {\Large Tesis de Licenciatura}\\[1em]
	    {\huge \textbf{$\lambda$Page}}\\[0.5em]
	    {\large \textit{Un bloc de notas para desarrolladores Haskell}}\\[1em]
	    \par\vspace{\stretch{1}}
	    {\large Departamento de Computaci—n}\\[0.5em]
	    {\large Facultad de Ciencias Exactas y Naturales}\\[0.5em]
	    {\large Universidad de Buenos Aires}
	    \par\vspace{\stretch{1}}
	    \begin{figure}[h]
	        \begin{center}
	        \includegraphics[width=40mm]{pictures/logoUba}
	        \end{center}
	    \end{figure}
	    {\Large \textbf{Alumno}}\\[0.8em]
	    {\Large Fernando Benavides (LU 470/01)} \par
	    {\Large greenmellon@gmail.com} \par
	    \par\vspace{\stretch{1}}
	    {\Large \textbf{Directores}}\\[0.8em]
	    {\Large Dr. Diego Garbervetsky} \par
	    {\Large Dr. Daniel Gor’n} \par
	    \par\vspace{\stretch{2}}
         {\Large \textbf{Abstract}}\\[0.5em]
    \end{center}
    El presente documento describe una herramienta para desarrolladores \haskell\ que pretende facilitar la tarea de ``debuggear'', analizar y entender c—digo, llamada \hpage.  Con ella el usuario puede manipular ``p‡ginas'' de texto libre que contengan expresiones \haskell, intentar interpretar estas expresiones independientemente y analizar los resultados obtenidos.
    \vspace*{\stretch{3}}
    \newpage

\tableofcontents

\newpage
\section{Estructura del Informe}
\paragraph{}El presente informe pretende presentar a \hpage, una herramienta para facilitar el trabajo de los desarrolladores \haskell.  El mismo se encuentra dividido en cuatro secciones.
\paragraph{}La primera es una secci—n en la que describiremos los motivos que nos llevaron a desarrollar esta herramienta, hablaremos tambiŽn de otras herramientas similares y presentaremos \hpage\ de modo general, mostrando principalmente el lugar que pretendemos que ocupe dentro del mundo \haskell.
\paragraph{}En la siguiente secci—n intentaremos mostrar, a travŽs de dos tutoriales, c—mo utilizar \hpage\ y daremos a conocer sus virtudes y capacidades.  Para comenzar, aprenderemos c—mo instalarlo, de modo que el lector pueda, una vez instalado el sistema, seguir los tutoriales paso a paso y realizar sus propias experiencias.
\subparagraph{}Luego, presentaremos un tutorial destinado al pœblico acadŽmico que nos mostrar‡ c—mo utilizar la herramienta para ayudar al alumno a resolver ejercicios pr‡cticos t’picos de varias materias de la facultad.  Veremos all’ la facilidad de trabajo que brinda \hpage\ al alumno permitiŽndole descubrir paso a paso el lenguaje y sus caracter’sticas principales.
\subparagraph{}El segundo tutorial que presentaremos est‡ apuntado a aquellos desarrolladores que trabajan con proyectos \haskell\ de dimensiones mayores a lo visto en el ‡mbito acadŽmico.  La idea de este tutorial es mostrar c—mo \hpage\ puede ayudarlos a entender c—digo existente y tambiŽn a generar y testear nuevo c—digo de manera sencilla y veloz.
\paragraph{}Una vez observado \hpage\ en funcionamiento y destacadas sus caracter’sticas principales, mostraremos c—mo ha sido dise–ado y construido.  Podremos ver los requerimientos que guiaron su dise–o, la arquitectura conceptual que lo subyace y las principales decisiones de dise–o e implementaci—n que se han tomado durante su desarrollo.
\paragraph{}Finalmente presentaremos los resultados obtenidos y los contrastaremos con los objetivos planteados al inicio de este desarrollo.  Estableceremos el estado del proyecto en general, cu‡les son los siguientes pasos a dar y quŽ otras tareas pueden llevarse a cabo a partir de ahora.

\newpage
\section{Introducci—n}
\subsection{Motivaci—n}
\begin{epigraphs}
    \qitem{Motivation is what gets you started. Habit is what keeps you going}{Jim Rohn}
    \qitem{Essstamo mo-ti-va-do, nene}{El ``Bambino'' Veira}
\end{epigraphs}
\paragraph{}Actualmente estamos presenciando un importante cambio en el desarrollo de sistemas, gracias al Žxito de proyectos como \htmladdnormallink{CouchDB}{http://couchdb.apache.org}~\cite{couchdb}, \htmladdnormallink{ejabberd}{http://www.ejabberd.im}~\cite{ejabberd} y el chat de \htmladdnormallink{Facebook}{http://www.facebook.com/}~\cite{facebook}, todos ellos desarrollados utilizando lenguajes del paradigma funcional.
\paragraph{}Ejemplos de Žstos lenguajes de programaci—n, como \htmladdnormallink{Haskell}{http://www.haskell.org}~\cite{haskell} o \htmladdnormallink{Erlang}{http://www.erlang.org}~\cite{erlang}, demuestran ser maduros, confiables y se presentan como una alternativa a los lenguajes tradicionales de otros paradigmas.  Sin embargo, los desarrolladores que deciden realizar el cambio de paradigma se encuentran con el problema de la escasez de ciertas herramientas que les permitan realizar su trabajo m‡s eficientemente.  Por el contrario, Žstas herramientas abundan en el desarrollo de proyectos utilizando lenguajes orientados a objetos.  En particular, nuestro foco de atenci—n se centra sobre aquellas herramientas que permiten realizar \textsl{debugging} y \textsl{entendimiento} de c—digo a travŽs de \textsl{``micro-testing''}\footnote{EntiŽndase \textsl{micro-testing} como la tarea de realizar tests eventuales para entender o evaluar algœn aspecto de un programa} .
\paragraph{}Los desarrolladores \haskell\ cuentan actualmente con las siguientes herramientas para realizar esta tarea:
\begin{description}
	\item[\htmladdnormallink{GHCi}{http://www.haskell.org/ghc/docs/latest/html/users\_guide/ghci.html}~\cite{ghci}]
		La consola que provee \htmladdnormallink{GHC}{http://www.haskell.org/ghc}~\cite{ghc} permite a los desarrolladores evaluar expresiones, verificar su tipo o su gŽnero.  Cuenta tambiŽn con un \htmladdnormallink{mecanismo de debugging}{http://www.haskell.org/ghc/docs/6.10-latest/html/users\_guide/ghci-debugger.html}~\cite{ghcdebug} integrado que permite realizar la evaluaci—n de expresiones paso a paso.  Pese a ser la herramienta m‡s utilizada por los desarrolladores, \textit{GHCi} tiene varias limitaciones.  En particular:
		\begin{itemize}
			\item No permite editar m‡s de una expresi—n a la vez
			\item No permite intercalar expresiones con definiciones
			\item	Si bien permite utilizar definiciones, Žstas se pierden al recargar m—dulos
			\item No es sencillo utilizar en una sesi—n las definiciones y/o expresiones creadas en sesiones anteriores
		\end{itemize}
	\item[\htmladdnormallink{Hugs}{http://www.haskell.org/hugs/}~\cite{hugs}]
		\textsl{Hugs98} es un intŽrprete peque–o y port‡til de Haskell escrito en C, de modo que funciona en casi cualquier m‡quina. \textsl{Hugs98}, que se utiliza principalmente como un sistema de desarrollo de programas para Haskell, es extremadamente r‡pido para la carga de m—dulos y tiene la ventaja de un intŽrprete interactivo (en el que uno puede pasar de un m—dulo a otro para probar diferentes partes de un programa).  Sin embargo, al ser un intŽrprete, ni siquiera se acerca a igualar el rendimiento en tiempo de ejecuci—n de, por ejemplo, programas compilados utilizando \textsl{GHC}.  Es, sin duda, el mejor sistema para los reciŽn llegados a aprender Haskell.  Provee muchas librer’as y la versi—n de Windows tiene una interfaz de usuario gr‡fica llamada \textsl{WinHugs}.
	\item[\htmladdnormallink{Hat}{http://www.haskell.org/hat}~\cite{hat}] Una herramienta para realizar seguimiento a nivel de c—digo fuente.  A travŽs de la generaci—n de trazas de ejecuci—n, \textit{Hat} ayuda a localizar errores en los programas y es œtil para entender su funcionamiento.  Sin embargo, por estar basado en la generaci—n de trazas, requiere la compilaci—n y ejecuci—n de un programa para poder utilizarlo y esto no siempre es c—modo para el desarrollador que puede querer simplemente analizar una expresi—n particular que incluso quiz‡ no compile aœn.  Adem‡s, su mantenimiento activo parece haber cesado hace m‡s de un a–o y en su p‡gina se observa una importante lista de problemas conocidos y caracter’sticas deseadas.
\end{description}

%%------------------------------------------------------------------------------------------------------------------------------
\subsection{Trabajos Relacionados}
\begin{epigraphs}
	\qitem{If I have seen further it is only by standing on the shoulders of giants}{Isaac Newton}
	\qitem{I like work; it fascinates me. I can sit and look at it for hours}{Jerome Klapka}
\end{epigraphs}
\paragraph{}En el mundo de la programaci—n orientada a objetos podemos encontrar herramientas como \htmladdnormallink{Java Scrapbook Pages}{http://help.eclipse.org/help33/index.jsp?topic=/org.eclipse.jdt.doc.user/reference/ref-34.htm}~\cite{javascrapbook} para \htmladdnormallink{Java}{http://www.java.com}~\cite{java}, y \htmladdnormallink{Workspace}{http://wiki.squeak.org/squeak/1934}~\cite{insidesmalltalk, smalltalkworkspace} para \htmladdnormallink{SmallTalk}{http://www.smalltalk.org}~\cite{smalltalk}.  Utilizando estos aplicativos, los desarrolladores pueden introducir peque–as porciones de c—digo, ejecutarlas y luego inspeccionar y analizar los resultados obtenidos.  Un concepto compartido por ambas herramientas es el de presentar ``p‡ginas'' de texto en las que varias expresiones pueden intercalarse con partes de texto libre y permitir al desarrollador intentar evaluar s—lo una porci—n de todo lo escrito.  Estas p‡ginas pueden ser guardadas y luego recuperadas de modo de poder analizar nuevamente las mismas expresiones.  Adem‡s permiten crear objetos (lo que para los lenguajes funcionales equivaldr’a a definir expresiones) locales a la p‡gina en uso y utilizarlos en ella.
\paragraph{}Dentro del paradigma funcional, con un enfoque similar, aunque un poco m‡s orientado a la presentaci—n y visualizaci—n de documentos, \htmladdnormallink{Keith Hanna}{http://www.cs.kent.ac.uk/people/staff/fkh/} de la Universidad de Kent, ha desarrollado \htmladdnormallink{Vital}{http://www.cs.kent.ac.uk/projects/vital/}~\cite{vital}.  \textsl{Vital} es una implementaci—n de un entorno de visualizaci—n de documentos para \haskell.  Pretende presentar \haskell\ de una manera apropiada para usuarios finales en ‡reas de aplicaci—n como la ingenier’a, las matem‡ticas o las finanzas.  Dentro de esta herramienta, los m—dulos \haskell\ son presentados como documentos en los que pueden visualizarse los valores que en ellos se definen directamente en el lugar en el que aparecen, ya sea de modo textual o gr‡fico (como ``vistas''). 
\paragraph{}Durante el desarrollo de \hpage\ hemos tenido que enfrentar varios desaf’os relacionados principalmente con el desarrollo de interfaces visuales dentro del paradigma funcional.  Volcando el conocimiento adquirido durante ese proceso, hemos desarrollado \htmladdnormallink{wxhNotepad}{http://github.com/elbrujohalcon/wxhnotepad}~\cite{wxhnotepad} que es, ante todo, una prueba de concepto sobre c—mo desarrollar editores de texto con \textsl{wxHaskell}.  Gracias a \htmladdnormallink{Jeremy O'Donoghue}{http://wewantarock.wordpress.com/about/}, \textsl{wxhNotepad} est‡ siendo publicado como \htmladdnormallink{un tutorial}{http://wewantarock.wordpress.com/2010/01/31/building-a-text-editor-part-1/}~\cite{wewantarock} en sucesivos art’culos en su blog
%%------------------------------------------------------------------------------------------------------------------------------
\subsection{\hpage}
\begin{epigraphs}
    \qitem{AncorchŽ lo ingegno umano faccia invenzioni varie, rispondendo con vari strumenti a un medesimo fine, mai esso trover\`a invenzione pi\`u bella, nŽ pi\`u facile nŽ pi\`u brieve della natura, perchŽ nelle sue invenzioni nulla manca e nulla \`e superfluo}{Leonardo da Vinci}
    \qitem{La programaci—n intensiva y el uso prolongado de Tetris s—lo lleva a ver estructuras de orden y secuencias en la verduler’a y a querer apilar los autos para formar l’neas s—lidas}{Dar’o Ruellan}
\end{epigraphs}
\paragraph{} \htmladdnormallink{\hpage}{http://haskell.hpage.com}~\cite{hpage} se presenta como una herramienta  similar al Workspace de \textit{Smalltalk}, que permite a los desarrolladores trabajar con documentos de texto libre que incluyan expresiones y definiciones.  \hpage\ es capaz de identificar las expresiones y definiciones v‡lidas y permite al desarrollador inspeccionarlas, evaluarlas, conocer su tipo y, en el caso de expresiones de tipo, conocer su gŽnero (o \textsl{kind}).
\subparagraph{}En el esp’ritu de las herramientas provistas por la comunidad de desarrolladores \haskell, \hpage\ se integra con \htmladdnormallink{Cabal}{http://www.haskell.org/cabal}~\cite{cabal} y \htmladdnormallink{Hayoo!}{http://holumbus.fh-wedel.de/hayoo}~\cite{hayoo} y se encuentra ya disponible en \htmladdnormallink{HackageDB}{http://hackage.haskell.org/package/hpage}~\cite{hackage}.  \cabal\ (Common Architecture for Building Applications and Libraries) es una API distribuida con GHC que permite a un desarrollador agrupar f‡cilmente un conjunto de m—dulos para producir un paquete. Es el sistema de compilaci—n est‡ndar para las aplicaciones y librer’as de \haskell.  \textsl{Hayoo!} es un motor de bœsqueda especializado en la documentaci—n de la API de \haskell.  El objetivo de \textsl{Hayoo!} es proporcionar una interfaz de bœsqueda interactiva y f‡cil de usar para la documentaci—n de varios paquetes y librer’as.  Por su parte, \textsl{HackageDB} es 
un repositorio en internet de versiones de software desarrollado en \haskell, almacenadas en paquetes \cabal.
\subparagraph{}\hpage\ presenta una interfaz simple e intuitiva, desarrollada utilizando \htmladdnormallink{wxHaskell}{http://haskell.org/haskellwiki/WxHaskell}~\cite{wxhaskell}, lo que lo convierte en una aplicaci—n multiplataforma.
\subparagraph{}Por ser una herramienta desarrollada con \haskell\ para \haskell, \hpage\ se diferencia de sus pares del mundo de objetos, al aprovechar conceptos claves como el \textsl{tipado est‡tico}, que permite detectar errores de tipo velozmente evitando el costo de evaluar expresiones complejas, y la \textsl{evaluaci—n perezosa}, que permite evaluar expresiones infinitas e ir exhibiendo resultados progresivamente.
\subparagraph{}A diferencia de \textsl{GHCi} que es una herramienta ``de consola'', \hpage\ permite visualizar resultados de manera m‡s din‡mica, permitiendo que errores intermedios (detectados durante la evaluaci—n de una expresi—n) no impidan continuar con la misma hasta llegar a un resultado m‡s completo.  De este modo, \hpage\ intenta brindar al usuario tanta informaci—n como le es posible obtener sobre la expresi—n que Žste quiere interpretar, m‡s all‡ de que ciertas porciones de esa expresi—n no puedan ser evaluadas o generen c‡lculos infinitos. 
\subparagraph{}\hpage\ se encuentra desarrollado utilizando \htmladdnormallink{\textsl{eprocess}}{http://hackage.haskell.org/package/eprocess}~\cite{eprocess}, una librer’a que facilita el manejo de ``threads'' en un estilo similar al de los procesos \textsl{Erlang}.  Utilizando esta librer’a, \hpage\ puede realizar tareas en paralelo y por lo tanto permitir al usuario continuar editando los documentos en los que est‡ trabajando mientras espera que se evalœe una expresi—n e incluso cancelar una evaluaci—n conservando la porci—n del resultado obtenida hasta ese momento.  Por otra parte, \hpage\ utiliza \textsl{eprocess} para detectar c‡lculos infinitos e informar sobre este hecho al usuario para que ya no siga esperando indefinidamente el resultado de la evaluaci—n solicitada.

\newpage
\section{Descubriendo \hpage}
\subsection{Instalaci—n}
\begin{epigraphs}
	\qitem{As a rule, software systems do not work well until they have been used, and have failed repeatedly, in real applications.}{Dave Parnas}
	\qitem{The \#1 programmer excuse for legitimately slacking off: ``My code is compiling''}{David Knutz}
\end{epigraphs}
\paragraph{}Para instalar \hpage\ en \textsl{OSX} o \textsl{Windows}, se proveen instaladores en \htmladdnormallink{el sitio web de \hpage}{http://github.com/elbrujohalcon/hPage/downloads}~\cite{hpage}, pero, como ya se ha dicho, \hpage\ se encuentra en \textsl{HackageDB} y por lo tanto el modo oficial de instalarlo es utilizando \cabal, con el siguiente comando:
\lstset{language=sh, frame=single, tabsize=2}
\begin{center}\begin{lstlisting}
$ cabal install hpage
\end{lstlisting}\end{center}
\subparagraph{}Sin embargo, para ello, previamente se deben satisfacer las siguientes dependencias:
\begin{description}
	\item[\htmladdnormallink{wxWidgets 2.8.10+}{http://www.wxwidgets.org/downloads/}~\cite{wxwidgets}] El framework de desarrollo para interfaces de usuario que utiliza \textsl{wxHaskell}.
	\item[\htmladdnormallink{Haskell Platform}{http://hackage.haskell.org/platform/}~\cite{platform}] Una distribuci—n de \haskell\ que incluye todo lo necesario para compilar e instalar programas desarrollados en este lenguaje (de particular interŽs para \hpage: \textsl{GHC} y \cabal).
\end{description}
\paragraph{}El proceso de instalaci—n de estas librer’as y \hpage\ a travŽs de \cabal\ var’a segœn la plataforma en la que se lo desee instalar.  Las instrucciones detalladas y actualizadas se encuentran disponibles en \htmladdnormallink{la \textsl{wiki} del sitio web de \hpage}{http://wiki.github.com/elbrujohalcon/hPage/installing-page}~\cite{hwiki}.

\newpage
\subsection{Caso de Uso: Aprobando PLP con \hpage}
\begin{epigraphs}
	\qitem{How is education supposed to make me feel smarter? Besides, every time I learn something new, it pushes some old stuff out of my brain - remember when I took that home winemaking course, and I forgot how to drive?}{Homer Simpson}
\end{epigraphs}
\paragraph{}Mostraremos a continuaci—n, a travŽs de un ejemplo, c—mo utilizar \hpage.  En este caso, hemos tomado prestada una pr‡ctica de la materia \textsl{Paradigmas de Lenguajes de Programaci—n}~\cite{plp}.  Exhibiremos entonces, c—mo un alumno podr’a utilizar \hpage\ en el proceso de resolver algunos de los ejercicios que all’ se presentan o verificar las soluciones que propone para otros.  Seleccionamos s—lo aquellos que a nuestro criterio son los m‡s representativos a la hora de entender c—mo \hpage\ ayuda al alumno.

\subsubsection{Pasos previos}
\paragraph{}Antes de comenzar a resolver los ejercicios, el alumno ejecuta \hpage\ y hace click en el bot—n \textsl{New}.  El programa presentar‡ una pantalla similar a la de la Figura~\ref{tut100}.
\begin{figure}[hp]
	\begin{center}
        	\includegraphics[width=.75\textwidth]{pictures/tut1/00}
		\caption{Tutorial 1 - Previo a comenzar}
		\label{tut100}
	\end{center}
\end{figure}

\newpage
\subsubsection{Definici—n de Tipos y Currificaci—n}

	\paragraph{\textsf{Ejercicio 1}}\textsf{Dado el siguiente programa, ?`Cu‡l es el tipo de \texttt{ys}?}
	\lstset{language=haskell, frame=single, tabsize=4}
	\begin{center}\begin{lstlisting}
		xs = [1,2,3]::[Float]
		ys = map (+) xs
	\end{lstlisting}\end{center}
	
\subparagraph{Uso de \hpage}En el caso de este ejercicio, el alumno deber’a deducir que el tipo de \texttt{ys} es \texttt{[Float -> Float]}.  Para chequear su deducci—n y asegurarse de haber obtenido el resultado deseado, puede ingresar el c—digo provisto por la c‡tedra en la p‡gina de \hpage, separando ambas expresiones por un rengl—n en blanco (pues ese es el modo utilizado por \hpage\ para determinar quŽ porci—n de la p‡gina corresponde a cada expresi—n). Luego agregar la expresi—n de la que desea conocer el tipo (\texttt{ys}) y finalmente, presionando el bot—n \textsl{Interpret}, puede ver el tipo del resultado (\texttt{[Float -> Float]}) como lo muestra la Figura~\ref{tut101}.
\begin{figure}[hp]
	\begin{center}
        	\includegraphics[width=.75\textwidth]{pictures/tut1/01}
		\caption{Tutorial 1 - Ejercicio 1}
		\label{tut101}
	\end{center}
\end{figure}

\subparagraph{}Notemos que \hpage\, al ser presionado el bot—n \textsl{Interpret} evalu— la expresi—n \texttt{ys}.  Esto se debe a que, cuando no hay ninguna porci—n del texto de la p‡gina seleccionada, \hpage\ evalœa la expresi—n sobre la cual se encuentra posicionado el cursor.  Al hacerlo considera todas las definiciones que se encuentran en la p‡gina. En nuestro ejemplo, \hpage\ interpret— \texttt{ys} y para hacerlo debi— recurrir tanto a su definici—n (\texttt{ys = map (+) xs}) como a la de \texttt{xs} (\texttt{xs = [1,2,3] :: [Float]}).

\newpage
\subsubsection{Listas por Comprensi—n}
\paragraph{\textsf{Ejercicio 4}}\textsf{?`Cu‡l es el valor de esta expresi—n?}
\lstset{language=haskell, frame=single, tabsize=4}
\begin{center}\begin{lstlisting}
	[ x | x <- [1..4], y <- [x..5], (x+y) `mod` 2 == 0 ]
\end{lstlisting}\end{center}
\subparagraph{Uso de \hpage}Nuevamente, en este ejercicio el alumno puede calcular el resultado manualmente y luego utilizar \hpage\ para chequear su resultado propuesto.  Para ello, ingresa el c—digo dentro de la p‡gina, selecciona la expresi—n (pues de ese modo indica a \hpage\ que, al momento de interpretar, s—lo quiere que sea considerada esa porci—n del texto de la p‡gina), y la evalœa presionando el bot—n \textsl{Interpret}.  \hpage\ mostrar‡ entonces el resultado: \texttt{[1,1,1,2,2,3,3,4]} como se ve en la Figura~\ref{tut102}.
\begin{figure}[hp]
	\begin{center}
        	\includegraphics[width=.75\textwidth]{pictures/tut1/02}
		\caption{Tutorial 1 - Ejercicio 4}
		\label{tut102}
	\end{center}
\end{figure}

\paragraph{\textsf{Ejercicio 5}}\textsf{Una tripla pitag—rica es una tripla $(a,b,c)$ de enteros positivos tal que $a^{2} + b^{2} = c^{2}$.  La siguiente es una definici—n de una lista (infinita) de triplas pitag—ricas.  Explicar por quŽ esta definici—n no es muy œtil.  Dar una definici—n mejor.}
\begin{center}\begin{lstlisting}
pitagorica :: [(Integer,Integer,Integer)] 
pitagorica = [(a,b,c) | a <- [1..], b <-[1..], c <- [1..], a^2 + b^2 == c^2] 
\end{lstlisting}\end{center}
\subparagraph{Uso de \hpage}Para resolver este ejercicio, el alumno podr’a comenzar por intentar evaluar la lista que se le provee, para ello escribir‡ su definici—n en una p‡gina de \hpage\ tal como se observa en la Figura~\ref{tut103} y, seleccionando las œltimas tres expresiones, presionar‡ el bot—n \textsl{Interpret}.  El espacio intermedio tiene la finalidad de distinguir ambas expresiones (por un lado, la declaraci—n de tipo y, por otro, la definici—n de la expresi—n)
\begin{figure}[hp]
	\begin{center}
        	\includegraphics[width=.75\textwidth]{pictures/tut1/03}
		\caption{Tutorial 1 - Ejercicio 5 - Primer intento}
		\label{tut103}
	\end{center}
\end{figure}
\subparagraph{}El alumno podr‡ visualizar entonces que el resultado de la interpretaci—n (si bien tiene un tipo v‡lido) nunca aparece por pantalla.  Esto se debe al modo en el que se evalœan las listas por comprensi—n en \haskell: En este caso, teniendo tres generadores (\texttt{a}, \texttt{b} y \texttt{c}) y siguiendo la sem‡ntica de \haskell\, para generar el primer elemento de la lista, el interprete toma el primer valor posible para \texttt{a} (o sea $1$), el primer valor posible para \texttt{b} (o sea $2$) y luego itera sobre \texttt{c}, con lo que intentar‡ verificar en cada paso de esta iteraci—n que $1^{2} + 1^{2} = c$.  Pero $1^{2}+1^{2} = 2$ y sabemos que no existe ningœn nœmero natural que elevado al cuadrado sea $2$, por lo tanto, el interprete nunca encontrar‡ el primer elemento de esta lista.  \hpage\ permite al alumno, pues, presionar el bot—n \textsl{Cancel} de modo de interrumpir la evaluaci—n y poder continuar trabajando.
\subparagraph{}Luego de presionar el bot—n \textsl{Cancel}, o incluso durante el lapso en el que \hpage\ trata de evaluar la expresi—n, el alumno puede modificar la definici—n de la funci—n \texttt{pitagorica} para cumplir con la consigna del ejercicio.  Podr’a, por ejemplo, reformularla como muestra la Figura~\ref{tut104} e intentar interpretarla, considerando que, dentro de los nœmeros naturales se cumple que $a > c \Rightarrow a^{2} > c^{2}$ y $b > c \Rightarrow b^{2} > c^{2}$.  \hpage\ entonces, comenzar‡ a exhibir resultados hasta que el alumno presione el bot—n \textsl{Cancel}.
\begin{figure}[hp]
	\begin{center}
        	\includegraphics[width=.75\textwidth]{pictures/tut1/04}
		\caption{Tutorial 1 - Ejercicio 5 - Segundo intento}
		\label{tut104}
	\end{center}
\end{figure}
\subparagraph{}Finalmente, el alumno podr’a tambiŽn verificar que puede obtener s—lo las 5 primeras tuplas pitag—ricas, definiendo la serie pitag—rica y tomando s—lo sus primeros 5 elementos como lo muestra la Figura~\ref{tut105}.  De este modo no necesitar’a presionar el bot—n \textsl{Cancel}.
\begin{figure}[hp]
	\begin{center}
        	\includegraphics[width=.75\textwidth]{pictures/tut1/05}
		\caption{Tutorial 1 - Ejercicio 5 - Tercer intento}
		\label{tut105}
	\end{center}
\end{figure}

\newpage
\subsubsection{Alto Orden y Esquemas de Recursi—n}
\paragraph{\textsf{Ejercicio 9}}\textsf{
\renewcommand{\theenumi}{\Roman{enumi}}
\begin{enumerate}
	\item Definir la funci—n \texttt{genLista}, que genera una lista de una cantidad dada de elementos, a partir de un elemento inicial y de una funci—n de incremento entre los elementos de la lista.  Dicha funci—n de incremento, dado un elemento de la lista, devuelve el elemento siguiente.
	\item Usando \texttt{genLista}, definir la funci—n \texttt{dh}, que dado un par de nœmeros (el primero menor que el segundo), devuelve una lista de nœmeros consecutivos desde el primero hasta el segundo.
\end{enumerate}
\renewcommand{\theenumi}{\arabic{enumi}}}
\subparagraph{Uso de \hpage}En este caso, ciertamente \hpage\ no puede ayudar al alumno a \textsl{crear} las funciones que se le solicitan, pero s’ puede ayudarlo a testearlas.  Supongamos pues que el alumno crea una nueva p‡gina y define en ella las funciones \texttt{genLista} y \texttt{dh} tal como se ve en la Figura~\ref{tut106}.  Luego, intenta testear su ejercicio y, tal como se ve en la Figura~\ref{tut107}, puede comprobar que sus funciones generan una recursi—n infinita.  Observa entonces que a \texttt{genLista} le falta un \textbf{caso base} y lo agrega, para luego volver a testear sus funciones como se ve en la Figura~\ref{tut108} y obtener as’ el resultado esperado.  Al igual que ya hemos visto en varios casos anteriores, debe dejar un rengl—n intermedio en blanco para que \hpage\ distinga las dos partes de la definici—n de la funci—n.
\begin{figure}[hp]
	\begin{center}
        	\includegraphics[width=.75\textwidth]{pictures/tut1/06}
		\caption{Tutorial 1 - Ejercicio 9 - Primer Intento}
		\label{tut106}
	\end{center}
\end{figure}
\begin{figure}[hp]
	\begin{center}
        	\includegraphics[width=.75\textwidth]{pictures/tut1/07}
		\caption{Tutorial 1 - Ejercicio 9 - Recursi—n Infinita}
		\label{tut107}
	\end{center}
\end{figure}
\begin{figure}[hp]
	\begin{center}
        	\includegraphics[width=.75\textwidth]{pictures/tut1/08}
		\caption{Tutorial 1 - Ejercicio 9 - Segundo Intento}
		\label{tut108}
	\end{center}
\end{figure}
\subparagraph{}Cabe aclarar que lo hecho en este ejercicio no es (ni pretende tampoco) ser un completo test de las funciones creadas.  Es simplemente lo que hemos llamado \textsl{micro-testing}: El ejercicio de realizar peque–as pruebas ``a mano'' utilizando expresiones cuyo resultado de evaluaci—n es previsible.

\newpage
\paragraph{\textsf{Ejercicio 23}}\textsf{Definimos el siguiente tipo:}
\begin{center}\begin{lstlisting}
	data Agenda p t = Vacia | Telefonos p [t] (Agenda p t)
\end{lstlisting}\end{center}
\subparagraph{}\textsf{Este tipo modela una agenda de telŽfonos.  A una agenda se le puede agregar una nueva entrada, donde se registra para una persona una lista de telŽfonos.  Una misma persona puede aparecer en varias entradas.  La lista de telŽfonos de una entrada puede contener repetidos.  Ejemplo:}
\begin{center}\begin{lstlisting}
miAgenda = Telefonos "Letincho" [42079999,43834567] 
           (Telefonos "Javi" [47779830] (Telefonos "Letincho" [42079999] Vacia)) 
\end{lstlisting}\end{center}
\textsf{\ldots}
\subparagraph{Uso de \hpage}El ejercicio continœa, pero en este caso, el alumno podr’a verse tentado a intentar evaluar \texttt{miAgenda} directamente en \hpage\ y obtendr’a el resultado de la Figura~\ref{tut109}.  ƒsto se debe a que \hpage\ no soporta definiciones de tipos de datos directamente en el texto.  Cabe aclarar que el error obtenido no es ``prolijo'' pues viene directamente de \textsl{GHC}, cuya API (utilizada por \hpage\ a travŽs de \textsl{hint} como se ver‡ en la Secci—n~\ref{secImplement}) no provee errores tipados, sino solamente descritos en forma de texto.
\begin{figure}[hp]
	\begin{center}
        	\includegraphics[width=.75\textwidth]{pictures/tut1/09}
		\caption{Tutorial 1 - Ejercicio 23 - Primer Intento}
		\label{tut109}
	\end{center}
\end{figure}
\subparagraph{}Para conseguir el efecto deseado, el alumno puede crear un m—dulo (sin salir de \hpage) y guardarlo utilizando la opci—n \textsl{Page $\rightarrow$ Save As\ldots} o el bot—n \textsl{Save}) tal como se observa en la Figura~\ref{tut110}.  Luego, utilizando la opci—n \textsl{Haskell $\rightarrow$ Load Modules\ldots} puede cargar el m—dulo reciŽn creado, seleccionar la expresi—n \texttt{miAgenda} y evaluarla normalmente.  Observamos el resultado de esta operaci—n en la Figura~\ref{tut111}
\begin{figure}[hp]
	\begin{center}
        	\includegraphics[width=.75\textwidth]{pictures/tut1/10}
		\caption{Tutorial 1 - Ejercicio 23 - Crear M—dulo}
		\label{tut110}
	\end{center}
\end{figure}
\begin{figure}[hp]
	\begin{center}
        	\includegraphics[width=.75\textwidth]{pictures/tut1/11}
		\caption{Tutorial 1 - Ejercicio 23 - Segundo Intento}
		\label{tut111}
	\end{center}
\end{figure}
\subparagraph{}Aprovechamos este momento para mencionar el hecho de que, si el alumno quisiese luego continuar trabajando en el m—dulo reciŽn creado, podr’a hacerlo y, ante cada modificaci—n, utilizar la opci—n \textsl{Haskell $\rightarrow$ Reload} o presionar el bot—n \textsl{Reload} para recargar el m—dulo, tomando as’ en contexto los cambios por Žl realizados.
\subparagraph{}Podemos ver, por un lado, que el resultado no ha sido mostrado, sino que s—lo se inform— su tipo.  Esto se debe a que el tipo \texttt{Agenda} no es instancia de la clase \texttt{Show}.  Para visualizar el resultado, el alumno podr’a agregar la cl‡usula \texttt{deriving (Show)} al tipo \texttt{Agenda}, grabar el m—dulo modificado, presionar el bot—n \textsl{Reload} y luego evaluar nuevamente \texttt{miAgenda} tal como se ve en la Figura~\ref{tut112}.
\begin{figure}[hp]
	\begin{center}
        	\includegraphics[width=.75\textwidth]{pictures/tut1/12}
		\caption{Tutorial 1 - Ejercicio 23 - Tercer Intento}
		\label{tut112}
	\end{center}
\end{figure}
\subparagraph{}Por otra parte, aprovecharemos este ejercicio simple para mostrar lo que \hpage\ permite hacer con los elementos de la lista \textsl{Modules}.  Presionando el bot—n derecho del mouse sobre un ’tem, \hpage\ despliega un menœ contextual que nos permite (entre otras opciones) ``navegar''  el m—dulo y conocer los elementos que exporta.  La Figura~\ref{tut113} nos muestra el ``‡rbol'' que se desprende de nuestro m—dulo \texttt{Temp}
\begin{figure}[hp]
	\begin{center}
        	\includegraphics[width=.75\textwidth]{pictures/tut1/13}
		\caption{Tutorial 1 - Navegando M—dulos}
		\label{tut113}
	\end{center}
\end{figure}

\newpage
\subsubsection{Conclusiones}
\paragraph{}En este tutorial hemos demostrado un uso sencillo de \hpage\ como herramienta de \textsl{micro-testing}, permitiendo al usuario trabajar con las funciones definidas en el \texttt{Prelude} de \haskell\ adem‡s de las que Žl mismo desee definir localmente.
\paragraph{}Pudimos apreciar c—mo \hpage\ permite definir expresiones y funciones, para luego evaluarlas de manera individual o combinada.  Pudimos ver que \hpage\ distingue unas expresiones de otras por encontrarse separadas utilizando renglones en blanco.  Vimos tambiŽn c—mo var’a el contexto de evaluaci—n (o sea, las expresiones que \hpage\ toma en consideraci—n al momento de realizar una interpretaci—n):
\begin{itemize}
	\item Si el usuario seleccion— una porci—n de texto, \hpage\ s—lo toma en consideraci—n las definiciones que se encuentren en la selecci—n e interpreta la œltima expresi—n del texto seleccionado
	\item Si el usuario, en cambio, no ha seleccionado texto alguno, \hpage\ toma en consideraci—n todas las definiciones de la p‡gina e interpreta la expresi—n sobre la que se encuentra posicionado por el cursor
\end{itemize}
\subparagraph{}Dichas evaluaciones pueden generar diversos resultados y hemos visto c—mo se maneja \hpage\ con algunos de ellos:
\begin{itemize}
	\item Para aquellas expresiones cuyo valor no puede ser expresado en forma de texto, hemos visto c—mo \hpage\ nos permite conocer su tipo.
	\item En el caso de expresiones cuyo valor es de longitud infinita, \hpage\ exhibe todo lo que el usuario desee del resultado, culminando cuando Žste presiona el bot—n \textsl{Cancel}.
	\item Y en relaci—n a aquellas que requieren un c‡lculo infinito para determinar su valor, \hpage\ muestra su tipo y permite al usuario continuar trabajando con las dem‡s expresiones hasta que decida presionar el bot—n \textsl{Cancel} e interrumpir de esa manera el c‡lculo.
\end{itemize}
\paragraph{}Esta forma de trabajar con los resultados, combinada con la posibilidad que brinda \hpage\ de editar definiciones de manera simple y directa, para luego volver a evaluar expresiones que las usan, permite al usuario trabajar fluidamente y le da la libertad de \textsl{cometer errores}, detectarlos, corregirlos y luego continuar su trabajo.  Esta caracter’stica de \hpage\ es muy importante sobre todo para quienes se encuentran dando sus primeros pasos en el mundo de \haskell\ pues, entendemos, facilita el aprendizaje del lenguaje.
\paragraph{}TambiŽn hemos visto en este tutorial c—mo se puede utilizar \hpage\ para crear, cargar, modificar y recargar m—dulos, trabajando siempre en una œnica p‡gina de texto.  ƒsta es otra caracter’stica de \hpage\ que facilita el trabajo ya no solamente a los estudiantes sino a todo tipo de desarrolladores \haskell.

\newpage
\subsection{Caso de Uso: Ganando al 4 en L’nea con \hpage}\label{secTut2}
\begin{epigraphs}
	\qitem{We learn by example and by direct experience because there are real limits to the adequacy of verbal instruction}{Malcom Gladwell}
	\qitem{Look behind you, a Three-Headed Monkey!}{Guybrush Threepwood}
\end{epigraphs}
\paragraph{}Incluimos en este informe un segundo tutorial, apuntando esta vez a mostrar c—mo \hpage\ puede ser de utilidad para un programador \haskell\ que se enfrenta a un problema complejo.  En Žl veremos como \hpage\ ayuda al usuario a ``entender'' c—digo escrito por otra persona (o quiz‡ por el mismo, algœn tiempo atr‡s).
\subsubsection{Introducci—n}
\paragraph{}La historia comienza cuando nuestra amiga desarrolladora, a quien llamaremos \textsl{F‡tima}\footnote{El nombre lo hemos elegido en honor a quien, hace ya casi 15 a–os y utilizando el sobrenombre \textsl{PersŽfone}, fue la \textsl{maestra} y principal rival de 4 en L’nea de Fernando Benavides en \htmladdnormallink{CyberJuegos}{http://www.cyberjuegos.com}} para darle un poco de personalidad, se encuentra con la misi—n de modificar una implementaci—n de un juego de \textsl{4 en L’nea}, llamada \htmladdnormallink{hfiar}{http://hackage.haskell.org/package/hfiar}~\cite{hfiar}.  F‡tima tiene que adaptar el juego de modo que permita \textsl{jugar contra la computadora} pues actualmente s—lo permite jugar a dos seres humanos entre s’.
\subparagraph{}Como es de suponer, F‡tima no conoce al creador del juego y no puede contactarlo por lo que sus œnicas herramientas, m‡s all‡ de su conocimiento de \haskell\ y del juego en s’, son el c—digo fuente de \textsl{hfiar} y \hpage.

\subsubsection{Primeros Pasos}
\paragraph{}Para comenzar, F‡tima descarga el c—digo del programa desde \textsl{HackageDB} y lo descomprime o bien clona el repositorio \textsl{Git} con el siguiente comando:
\lstset{language=sh, frame=single, tabsize=2}
\begin{center}\begin{lstlisting}
$ git clone git://github.com/elbrujohalcon/hfiar.git
\end{lstlisting}\end{center}
\begin{figure}[hp]
	\begin{center}
        	\includegraphics{pictures/tut2/00}
		\caption{Tutorial 2 - Archivos Originales}
		\label{tut200}
	\end{center}
\end{figure}
\paragraph{}Una vez hecho eso, puede observar la estructura del proyecto, tal como se ve en la Figura~\ref{tut200}.  Conociendo la estructura b‡sica de los proyectos desarrollados en \haskell, podemos describir los archivos all’ presentes de la siguiente manera:
\begin{description}
\item[hfiar.cabal] Archivo de descripci—n de proyecto \cabal.  F‡tima puede obtener de Žl informaci—n general del proyecto, sus m—dulos, las dependencias y extensiones del lenguaje que se necesitan para compilarlo, entre otros datos.
\item[Setup.hs] Archivo \haskell\ utilizado por \cabal\ para realizar tareas especiales al momento de configurar, compilar o instalar la aplicaci—n.  Junto con \textbf{hfiar.cabal} permite instalar el proyecto utilizando las siguientes instrucciones:
		\begin{center}\begin{lstlisting}
$ cabal configure --user
$ cabal build
$ cabal install
		\end{lstlisting}\end{center}
\item[src] Carpeta que contiene los archivos de c—digo fuente del proyecto.  F‡tima deber‡ analizar cada uno de ellos por separado para poder comprender su funcionamiento.
\item[LICENSE] Archivo con la licencia del proyecto, en este caso \htmladdnormallink{BSD3}{http://www.linfo.org/bsdlicense.html}~\cite{bsd}.
\item[README] En el caso de este proyecto, no se trata de algo demasiado œtil, dice simplemente:
\begin{verbatim}
Four in a Row in Haskell!!
See http://hackage.haskell.org/package/hfiar
\end{verbatim}
\end{description}

\newpage
\subsubsection{Entendiendo el Proyecto}
\paragraph{}Para comenzar a entender c—mo est‡ estructurada la aplicaci—n, F‡tima abre el archivo \textbf{hfiar.cabal} (al que podemos ver en la Figura~\ref{tut201}) y observa que el proyecto se encuentra compuesto por una librer’a (que expone solamente al m—dulo \texttt{HFiaR}) y un ejecutable llamado \texttt{hfiar} que, m‡s all‡ del m—dulo \texttt{Main}, incluye a los m—dulos \texttt{HFiaR.GUI} y \texttt{HFiaR.Server}.  F‡tima puede ver adem‡s que, para compilar los m—dulos del proyecto, debe utilizar las extensiones \textbf{MultiParamTypeClasses} y \textbf{GeneralizedNewtypeDeriving}.
\begin{figure}[hp]
	\begin{center}
	\hbox{}
		\begin{center}\begin{lstlisting}
name: hfiar
version: 2.0.4
cabal-version: >=1.6
build-type: Custom
license: BSD3
license-file: LICENSE
copyright: 2010 Fernando "Brujo" Benavides
maintainer: greenmellon@gmail.com
stability: stable
homepage: http://github.com/elbrujohalcon/hfiar
package-url: http://code.haskell.org/hfiar
bug-reports: http://github.com/elbrujohalcon/hfiar/issues
synopsis: Four in a Row in Haskell!!
description: The classical game, implemented with wxHaskell
category: Game
author: Fernando "Brujo" Benavides
tested-with: GHC ==6.12.1
data-files: LICENSE README
data-dir: ""
extra-source-files: Setup.hs
extra-tmp-files:

source-repository head
    type:     git
    location: git://github.com/elbrujohalcon/hfiar.git

Library
    build-depends: base >= 4,                   base < 5,
                   mtl >=1.1.0,                 mtl < 1.2,
                   eprocess >= 1.1.2,           eprocess < 2
    extensions: MultiParamTypeClasses, GeneralizedNewtypeDeriving
    exposed-modules: HFiaR
    hs-source-dirs: src

Executable hfiar
    build-depends: wxcore >=0.12.1.4,           wxcore < 0.13,
                   wx >=0.12.1.4,               wx < 0.13
    extensions: MultiParamTypeClasses, GeneralizedNewtypeDeriving
    main-is: Main.hs
    buildable: True
    hs-source-dirs: src
    other-modules: HFiaR.GUI, HFiaR.Server
    ghc-options: -Wall
    			\end{lstlisting}\end{center}
		\caption{Tutorial 2 - hfiar.cabal}
		\label{tut201}
	\end{center}
\end{figure}
\subparagraph{}Habiendo realizado este an‡lisis, F‡tima configura el proyecto ejecutando la siguiente instrucci—n:
\begin{center}\begin{lstlisting}
$ cabal configure --user
\end{lstlisting}\end{center}
\subparagraph{}Sabiendo que existe una librer’a en el proyecto, F‡tima intenta generar su documentaci—n, ejecutando:
\begin{center}\begin{lstlisting}
$ cabal haddock
\end{lstlisting}\end{center}
\subparagraph{}En el caso de \textsl{hfiar}, ese comando genera la documentaci—n en formato HTML, siendo su p‡gina principal \texttt{dist/doc/html/hfiar/index.html}.  F‡tima encuentra all’ una descripci—n de los componentes del m—dulo \texttt{HFiaR}.  Armada con estos datos, se dispone a utilizar \hpage\ para comprender c—mo funcionan esos componentes.

\newpage
\subsubsection{Utilizando \hpage}
\paragraph{}Una vez abierto \hpage, F‡tima puede intentar cargar el proyecto utilizando la opci—n \textsl{Haskell $\rightarrow$ Load Package\ldots} o el bot—n \textsl{Load Package}.  Eso abre una ventana en la que F‡tima debe seleccionar el archivo \textbf{setup-config} generado por \cabal, tal como se ve en la Figura~\ref{tut202}.
\begin{figure}[hp]
	\begin{center}
        	\includegraphics[width=.75\textwidth]{pictures/tut2/02}
		\caption{Tutorial 2 - Cargando un proyecto \cabal}
		\label{tut202}
	\end{center}
\end{figure}
\subparagraph{}F‡tima tendr‡ entonces a su disposici—n los m—dulos que componen la aplicaci—n y, haciendo click con el bot—n derecho del mouse en ellos, podr‡ cargarlos, como se ve en la Figura~\ref{tut203}.  \textsl{Cargar} un m—dulo es la acci—n de poner en contexto las funciones y tipos de datos definidos en Žl, de modo que puedan ser utilizados dentro de las p‡ginas actuales.  Al \textsl{cargar} un m—dulo, \hpage\ carga recursivamente los m—dulos de los que Žste depende.  Todos los m—dulos previamente cargados, excepto los m—dulos del paquete, se olvidan.  Si existe c—digo precompilado para el m—dulo, \hpage\ lo utiliza.  En otro caso, intenta compilar su c—digo desde el archivo fuente.  Cabe destacar que utilizar c—digo precompilado tiene ventajas y desventajas.  Por un lado, al estar precompilado, un m—dulo es cargado m‡s velozmente y, adem‡s, quien lo haya compilado pudo haber utilizado distintas opciones de compilaci—n, por ejemplo, con el objetivo de generar c—digo optimizado.  Pero, por otra parte, el usuario de \hpage\ ya no tendr‡ acceso a las funciones internas del mismo, como lo tendr’a si el m—dulo fuese cargado desde su archivo fuente.
\begin{figure}[hp]
	\begin{center}
        	\includegraphics[width=.75\textwidth]{pictures/tut2/03}
		\caption{Tutorial 2 - Proyecto \cabal\ cargado}
		\label{tut203}
	\end{center}
\end{figure}

\newpage
\paragraph{}Recordando que el proyecto inclu’a una librer’a compuesta œnicamente por el m—dulo \texttt{HFiaR}, nuestra amiga F‡tima decide cargarlo y navegarlo utilizando el menœ desplegable que nos muestra la Figura~\ref{tut204}.
\begin{figure}[hp]
	\begin{center}
        	\includegraphics[width=.75\textwidth]{pictures/tut2/04}
		\caption{Tutorial 2 - M—dulo \texttt{HFiaR}}
		\label{tut204}
	\end{center}
\end{figure}
\paragraph{}Gracias a la documentaci—n generada previamente, puede comprender que la din‡mica del juego est‡ modelada con una m—nada~\cite{monads} que describe las acciones llevadas a cabo durante un partido.  El concepto de \textsl{m—nada} (monad) es uno de los m‡s dif’ciles de comprender para aquellos que dan sus primeros pasos en \haskell.  A los fines de este tutorial, podemos ver a las m—nadas como tipos de datos que nos permiten definir acciones que generan resultados (por ejemplo, \texttt{dropIn} o \texttt{player} son acciones de la m—nada \texttt{HFiaR}) y concatenarlas utilizando distintos operadores genŽricos (como \texttt{$>>$}) para generar nuevas acciones m‡s complejas (como por ejemplo, \texttt{dropIn 1 $>>$ player}, que es una acci—n de la m—nada \texttt{HFiaR} que representa el hecho de arrojar una ficha en la columna 1 y luego verificar cu‡l es el jugador actual).  Estas acciones, luego pueden ser ``ejecutadas''.  En nuestro caso dicha ejecuci—n se realiza, por ejemplo, utilizando las funciones \texttt{play} (cuyo resultado refleja el estado del partido una vez ejecutada las acci—n) o \texttt{eval} (cuyo resultado es el de la acci—n ejecutada).
\subparagraph{}F‡tima verifica las funciones de la m—nada \texttt{HFiaR} con las que cuenta:
\begin{description}
	\item[\texttt{dropIn}] representa el hecho de arrojar una ficha en una columna
	\item[\texttt{tryDropIn}] representa el hecho de verificar quŽ pasar’a en el caso de realizar serie de jugadas, donde cada una de ellas corresponde a arrojar una ficha en una columna.  Es similar a \texttt{dropIn} pero sin que el juego avance
	\item[\texttt{player}] le permite conocer el jugador actual
	\item[\texttt{board}] le permite observar el tablero, que es modelado como una lista de listas de \texttt{Tile}s, o sea fichas
	\item[\texttt{result}] le permite verificar el resultado del partido, si es que el mismo ha concluido
\end{description}

\subparagraph{}Como el lector, al igual que F‡tima, habr‡ podido ver en la Figura~\ref{tut204}, si bien las acciones que pueden definirse corresponden a la m—nada \texttt{HFiaR}, dado el tipo de \texttt{play} y \texttt{eval}, las mismas pueden ser ejecutadas dentro de cualquier m—nada.  Esto se debe a que la m—nada est‡ implementada utilizando la tŽcnica de \textsl{Monad Transformers}~\cite{mtl}.  Los \textsl{Transformadores de M—nadas} (Monad Transformers) son variantes especiales de las m—nadas que facilitan la combinaci—n de m—nadas.  Sus constructores de tipo tienen como par‡metro un tipo mon‡dico y producen tipos mon‡dicos combinados.  En este tutorial, por ejemplo, las funciones \texttt{justPlay} y \texttt{justEval}, est‡n definidas internamente utilizando el tipo transformador \texttt{HFiaRT} para ejecutar acciones de la m—nada \texttt{HFiaR} dentro de la m—nada \texttt{IO}.

\subparagraph{}Utilizando estas funciones, F‡tima comienza a realizar su tarea de \textsl{micro-testing}.  Su primera prueba consiste en \textit{jugar} un partido en el que nada pasa, s—lo para ver quŽ informaci—n puede obtener de Žl.  Coloca entonces en la p‡gina la expresi—n que presentamos a continuaci—n e intenta interpretarla tal como se ve en la Figura~\ref{tut205}.  Esta expresi—n, aunque simple, presenta dos elementos muy utilizados por los desarrolladores \haskell: el operador \$, que equivale a encerrar entre parŽntesis lo que sigue en la expresi—n, facilitando la lectura de la expresi—n en su totalidad, y la expresi—n \texttt{return ()}, que es la acci—n que representa el hecho de simplemente ``no hacer nada''.  Como toda acci—n debe tener un resultado, el de \texttt{return ()} es \texttt{()}, el œnico valor posible de tipo \texttt{Unit}.
\lstset{language=haskell, frame=single, tabsize=4}
\begin{center}\begin{lstlisting}
	justPlay $ return ()
\end{lstlisting}\end{center}
\begin{figure}[hp]
	\begin{center}
        	\includegraphics[width=.75\textwidth]{pictures/tut2/05}
		\caption{Tutorial 2 - Juego M’nimo}
		\label{tut205}
	\end{center}
\end{figure}
\subparagraph{}El resultado obtenido es el que sigue y puede interpretarse como \textsl{``el partido se encuentra en curso, es el turno del jugador que juega con fichas verdes y el tablero est‡ vac’o''}.  Cabe notar que el tipo del resultado es \texttt{IO Game}, o sea, una acci—n con posibles efectos colaterales de entrada/salida (dentro de la m—nada \texttt{IO}) cuyo resultado es un juego (\texttt{Game}).  Sin embargo, el resultado obtenido representa simplemente a un juego.  Esto se debe a que \hpage, siguiendo el ejemplo de \textsl{GHCi}, trata de manera especial a las acciones de la m—nada \texttt{IO} y, en lugar de intentar mostrarlas (cosa que, por cierto, no podr’a hacer) las evalœa y luego intenta presentar su resultado.
\begin{center}\begin{lstlisting}
OnCourse {gamePlayer = Green,
          gameBoard = [[],[],[],[],[],[],[]]}
\end{lstlisting}\end{center}
\newpage
\paragraph{}Usando \hpage, F‡tima realiza varias otras pruebas que consignamos en la tabla que presentamos a continuaci—n.  Con ellas puede entender el funcionamiento general de la m—nada \texttt{HFiaR} y de ese modo determinar c—mo su jugador de inteligencia artificial puede contemplar el desarrollo del juego, saber si el mismo ha concluido o no, si es su turno, cu‡l es el estado del tablero y entonces elegir c—mo jugar.  Cabe notar que los resultados de tipo \texttt{Left HFiaRError} se exhiben como texto porque el desarrollador de \textsl{hfiar} ha decidido utilizar la funci—n \texttt{show} para describir los errores en lugar de exhibir su constructor.

\lstset{language=haskell, frame=none, tabsize=4}
	\begin{table}[hp]
		\begin{center}
			\begin{tabular}{@{} cc @{}}
				\toprule
				Expresi—n & Resultado \\ 
				\midrule
\begin{lstlisting}
justPlay $ return ()
\end{lstlisting} &
\begin{lstlisting}
OnCourse {gamePlayer = Green,
          gameBoard = [[],[],[],[],[],[],[]]}
\end{lstlisting} \\[1.5em]

\begin{lstlisting}
justEval player
\end{lstlisting} &
\begin{lstlisting}
Right Green
\end{lstlisting} \\[1.5em]

\begin{lstlisting}
justEval $ dropIn 1 >> board
\end{lstlisting} &
\begin{lstlisting}
[[],[Green],[],[],[],[],[]]
\end{lstlisting} \\[1.5em]

\begin{lstlisting}
justEval $ dropIn 1 >> 
           dropIn 2 >> board
\end{lstlisting} &
\begin{lstlisting}
[[],[Green],[Red],[],[],[],[]]
\end{lstlisting} \\[1.5em]

\begin{lstlisting}
justEval $ dropIn 1 >> dropIn 1 >>
           dropIn 2 >> board
\end{lstlisting} &
\begin{lstlisting}
[[],[Red, Green],[Green],[],[],[],[]]
\end{lstlisting} \\[1.5em]

\begin{lstlisting}
justEval $ dropIn 7
\end{lstlisting} &
\begin{lstlisting}
Left That column doesn't exist
\end{lstlisting} \\[1.5em]

\begin{lstlisting}
justPlay $ dropIn 4 >> dropIn 1 >>
           dropIn 4 >> dropIn 1 >>
           dropIn 4 >> dropIn 1 >>
           dropIn 4
\end{lstlisting} &
\begin{lstlisting}
Ended {gameResult = WonBy Green,
       gameBoard = [[],[Red,Red,Red],
                    [],[],
                    [Green,Green,Green,Green],
                    [],[]]}
\end{lstlisting} \\[1.5em]

\begin{lstlisting}
justEval $ dropIn 4 >> dropIn 1 >>
           dropIn 4 >> dropIn 1 >>
           dropIn 4 >> dropIn 1 >>
           dropIn 4 >> result
\end{lstlisting} &
\begin{lstlisting}
Right (WonBy Green)
\end{lstlisting} \\[1.5em]

\begin{lstlisting}
justEval $ dropIn 4 >> dropIn 1 >>
           dropIn 4 >> dropIn 1 >>
           dropIn 3 >> dropIn 1 >>
           dropIn 4 >> result
\end{lstlisting} &
\begin{lstlisting}
Left Game is still on course
\end{lstlisting} \\[1.5em]

\begin{lstlisting}
justEval $ dropIn 1 >> dropIn 1 >>
           dropIn 1 >> dropIn 1 >>
           dropIn 1 >> dropIn 1 >>
           dropIn 1 >> dropIn 1
\end{lstlisting} &
\begin{lstlisting}
Left That column is full
\end{lstlisting} \\[1.5em]

			\bottomrule
		\end{tabular}
		\caption{Tutorial 2 - Pruebas realizadas en \hpage}
	\end{center}
\end{table}
\lstset{language=haskell, frame=single, tabsize=4}

\newpage
\subsubsection{Creando al \textsl{Jugador Computadora}}
\paragraph{}Con el conocimiento adquirido en el uso de \texttt{HFiaR}, F‡tima decide crear la funci—n \texttt{aiDropIn}, que se ejecutar‡ dentro de la m—nada \texttt{HFiaR}.  A continuaci—n observamos el tipo de dicha funci—n.  Se puede ver que el tipo de la funci—n es similar al de \texttt{dropIn}, salvo por el hecho de no recibir el nœmero de columna en la que el jugador desea volcar su ficha.  Eso se debe, justamente, a que ser‡ la propia funci—n quiŽn lo determine.
\begin{center}\begin{lstlisting}
-- | Drop a tile in a column choosen by the Artificial Inteligence
aiDropIn :: Monad m => HFiaRT m (Either HFiaRError ())
\end{lstlisting}\end{center}
\subparagraph{}Para crear \texttt{aiDropIn}, F‡tima no cierra \hpage.  Por el contrario, define la funci—n all’ mismo, como podemos ver en la Figura~\ref{tut207}, componiŽndola con otra funci—n a la que denomina \texttt{bestColumn}.  Esta funci—n se ejecutar‡ s—lo en el caso de que el partido no haya concluido.  La idea es que en ella estar‡ el algoritmo principal de selecci—n de columna a jugar (o sea, el verdadero motor de \textsl{inteligencia artificial}), el cual se ir‡ perfeccionando a lo largo del tutorial.  La primera versi—n de \texttt{bestColumn}, con m‡s de artificial que de inteligencia, simplemente elegir‡ la primer columna que no estŽ llena y \texttt{aiDropIn} arrojar‡ la ficha ah’.  Recordamos que, para que \hpage\ reconozca las distintas expresiones, F‡tima debe separarlas con renglones en blanco.
\begin{figure}[hp]
	\begin{center}
        	\includegraphics[width=.75\textwidth]{pictures/tut2/06}
		\caption{Tutorial 2 - \texttt{aiDropIn} versi—n 1}
		\label{tut207}
	\end{center}
\end{figure}

\newpage
\subparagraph{}Una vez definidas ambas funciones, F‡tima decide testearlas y, para ello, no necesita m‡s que \textsl{evaluar} un juego en el que conozca el resultado.  En particular, F‡tima elije hacer jugar a la computadora contra s’ misma 8 movimientos y verifica que las fichas han quedado intercaladas en la primer columna y luego el siguiente jugador ha colocado una en la segunda.
\paragraph{}El siguiente paso es agregar un poco de inteligencia a \texttt{bestColumn} de modo de que realmente sea competitivo.  Para ello, F‡tima prevŽ que necesitar‡ varias funciones auxiliares y una buena cantidad de c—digo, por lo que decide convertir su p‡gina actual en un m—dulo al que denomina \texttt{HFiaR.AI} y graba en el lugar correspondiente entre los fuentes del proyecto, utilizando la opci—n \textsl{Page $\rightarrow$ Save As\ldots} o el bot—n \textsl{Save}.  A partir de ese momento, F‡tima puede utilizar su editor \haskell\ favorito para agregar la cabecera del m—dulo, la importaci—n del m—dulo que ten’a cargado (\texttt{HFiaR}) y ``bautizar'' la expresi—n utilizada para testear como \texttt{testGame}.  Luego lo carga utilizando la opci—n \textsl{Haskell $\rightarrow$ Load Modules\ldots} y entonces, en una p‡gina nueva (creada utilizando la opci—n \textsl{Page $\rightarrow$ New}) escribe e interpreta la expresi—n \texttt{testGame}, de modo de realizar la misma prueba de la Figura~\ref{tut207}.  Es interesante notar que, pese a que el m—dulo creado s—lo exporta la funci—n \texttt{aiDropIn}, F‡tima pudo interpretar sin problemas la funci—n \texttt{testGame}, pues hab’a cargado el m—dulo utilizando el archivo con su c—digo fuente y eso le da acceso a todas las funciones del mismo, tanto pœblicas como privadas.  A partir de este momento, F‡tima utiliza su editor favorito para trabajar en el m—dulo que ha creado y, ante cada modificaci—n, lo recarga utilizando la opci—n \textsl{Haskell $\rightarrow$ Reload} o el bot—n \textsl{Reload}.
\subparagraph{}Para la segunda (y a los fines de este tutorial, definitiva) versi—n de \texttt{bestColumn}, experta jugadora de 4 en l’nea como es, F‡tima pone un poco de criterio y decide que la funci—n tenga en cuenta las condiciones que enumeramos a continuaci—n:
\begin{itemize}
	\item Si poniendo la ficha en alguna columna el jugador gana el partido, se debe elegir esa columna.
	\item Si poniendo la ficha en alguna columna se impide que el jugador rival gane el partido (pues acumula 3 alineadas convenientemente) se debe elegir esa columna.
	\item En otro caso, de ser posible, debe elegirse la columna 3 (o sea, la columna central) pues para formar l’neas de 4 fichas horizontales o diagonales se requiere una ficha en dicha columna
\end{itemize}

\newpage
\subparagraph{}Presentamos entonces la nueva versi—n de \texttt{bestColumn} y sus funciones adicionales:
\begin{center}\begin{lstlisting}
module HFiaR.AI (aiDropIn) where

import HFiaR
import Data.Maybe

bestColumn :: Monad m => HFiaRT m Int
bestColumn =
    do
        j1 <- columnWhereWins
        j2 <- columnWhereLoses
        j3 <- column3IfAvailable
        j4 <- firstAvailableColumn
        return . head $ catMaybes [j1, j2, j3, j4]

columnWhereWins, columnWhereLoses,
    column3IfAvailable, firstAvailableColumn :: Monad m => HFiaRT m (Maybe Int)

columnWhereWins = mapM (tryDropIn . (:[])) [0..6] >>= return . firstEnded

columnWhereLoses = mapM moves [0..6] >>= return . firstEnded
    where moves :: Monad m => Int -> HFiaRT m (Either HFiaRError Game)
          moves col = do
            b <- board
            let avail c = c == col || length (b!!c) == 7
            let other = length $ takeWhile avail [0..6]
            tryDropIn [other, col]

column3IfAvailable = board >>= \b -> return $ case length (b !! 3) of
                                                    7 -> Nothing
                                                    _ -> Just 3

firstAvailableColumn = board >>=
						return . Just . length . takeWhile (\c -> length c == 7)

firstEnded :: [Either HFiaRError Game] -> Maybe Int
firstEnded games = case (length $ takeWhile onCourse games) of
                        7 -> Nothing
                        g -> Just g
    where onCourse (Left _)           = False
          onCourse (Right OnCourse{}) = True
          onCourse (Right Ended{})    = False
\end{lstlisting}\end{center}
\subparagraph{} Muchas porciones del c—digo que acabamos de exponer pueden resultar desconocidas o quiz‡s dif’ciles de comprender incluso para un programador \haskell\ ya habituado a este tipo de c—digo.  Tomemos, por ejemplo, la funci—n \texttt{catMaybes}, utilizada en la nueva versi—n de \texttt{bestColumn}.  A los fines de continuar con nuestra historia y demostrar el uso de \hpage, supongamos que, si bien F‡tima sab’a de la existencia de esta funci—n, no sab’a en quŽ m—dulo se encontraba declarada ni recordaba exactamente su tipo.  En tal caso, lo que puede hacer es escribir el nombre de la funci—n en la p‡gina de \hpage, seleccionarlo y utilizar la opci—n \textsl{Search on Hayoo!} del menœ contextual que se despliega al presionar el bot—n derecho del mouse sobre el texto seleccionado.  En ese momento, \hpage\ le presentar‡ la p‡gina web que se ve en la Figura~\ref{tut209}. All’ se puede observar que la funci—n \texttt{catMaybes} se encuentra definida en el m—dulo \texttt{Data.Maybe} y que su tipo es \texttt{[Maybe a] -> [a]}.  M‡s aœn, \textsl{Hayoo!} nos muestra la documentaci—n que acompa–a a la funci—n, segœn la cual \textit{la funci—n \texttt{catMaybes} toma una lista de \texttt{Maybe}s y devuelve una lista de todos los valores construidos con \texttt{Just}}.  Para probarla, F‡tima puede importar el m—dulo \textsl{Data.Maybe} utilizando la opci—n \textsl{Haskell $\rightarrow$ Import modules\ldots} y realizar alguna prueba similar a la de la Figura~\ref{tut210}. 
\subparagraph{}El lector podr’a preguntarse en este momento por quŽ F‡tima debi— importar el m—dulo en lugar de cargarlo como ha hecho con los dem‡s m—dulos.  Esto se debe a que el m—dulo \textsl{Data.Maybe} se encuentra en una librer’a del sistema, por lo tanto \hpage\ no tiene acceso a su c—digo fuente ni a su versi—n precompilada.  \textsl{Importar} un m—dulo es similar a cargarlo: es la acci—n de poner en contexto las funciones y tipos de datos definidos y \textbf{exportados} por Žl, de modo que puedan ser utilizados dentro de las p‡ginas actuales.  Al importar un m—dulo, el usuario no tiene acceso a las funciones y tipos de datos \textsl{privados} del mismo.
\begin{figure}[hp]
	\begin{center}
        	\includegraphics[width=.75\textwidth]{pictures/tut2/09}
		\caption{Tutorial 2 - Utilizando \textsl{Hayoo!}}
		\label{tut209}
	\end{center}
\end{figure}
\begin{figure}[hp]
	\begin{center}
        	\includegraphics[width=.75\textwidth]{pictures/tut2/10}
		\caption{Tutorial 2 - Testeando \texttt{catMaybes}}
		\label{tut210}
	\end{center}
\end{figure}

\newpage
\paragraph{} La funci—n \texttt{testGame} ya no es suficiente para testear el funcionamiento de \texttt{aiDropin}.  Lo que hace F‡tima, aprovechando la facilidad que le brinda \hpage\ para ejecutar acciones de la m—nada \texttt{IO}, es crear una funci—n auxiliar llamada \texttt{round} que, adem‡s de completar una ronda del juego (o sea, un turno jugado por el usuario y otro por la inteligencia artificial) guarda registro del estado del juego en un archivo de log.  De ese modo puede probar el comportamiento de su m—dulo de inteligencia artificial ante las distintas circunstancias de un partido tan extenso como ella desee.  Cabe destacar una vez m‡s aqu’ que cada vez que F‡tima desee realizar cambios en su m—dulo puede hacerlo con su editor favorito y luego presionar el bot—n \textsl{Reload} al volver a \hpage\ e interpretar nuevamente sus expresiones, que no han sido perdidas pues est‡n todav’a en la(s) p‡gina(s) con la(s) que est‡ trabajando.  A modo de ejemplo, en la Figura~\ref{tut212}, presentamos el archivo resultante de la interpretaci—n de la expresi—n que muestra la figura \ref{tut211}.
\begin{figure}[hp]
	\begin{center}
        	\includegraphics[width=.75\textwidth]{pictures/tut2/08}
		\caption{Tutorial 2 - \textsl{Jugando} contra \texttt{HFiaR.AI}}
		\label{tut211}
	\end{center}
\end{figure}
\begin{figure}[hp]
	\begin{center}
	\hbox{}
		\begin{lstlisting}
Human turn: Right ()
	[[],[],[],[Green],[],[],[]]
	Left Game is still on course
AI turn: Right ()
	[[],[],[],[Red,Green],[],[],[]]
	Left Game is still on course
Human turn: Right ()
	[[],[],[],[Green,Red,Green],[],[],[]]
	Left Game is still on course
AI turn: Right ()
	[[],[],[],[Red,Green,Red,Green],[],[],[]]
	Left Game is still on course
Human turn: Right ()
	[[],[Green],[],[Red,Green,Red,Green],[],[],[]]
	Left Game is still on course
AI turn: Right ()
	[[],[Green],[],[Red,Red,Green,Red,Green],[],[],[]]
	Left Game is still on course
Human turn: Right ()
	[[],[Green],[],[Green,Red,Red,Green,Red,Green],[],[],[]]
	Left Game is still on course
AI turn: Right ()
	[[],[Green],[],[Red,Green,Red,Red,Green,Red,Green],[],[],[]]
	Left Game is still on course
Human turn: Right ()
	[[],[Green],[Green],[Red,Green,Red,Red,Green,Red,Green],[],[],[]]
	Left Game is still on course
AI turn: Left That column is full
	[[],[Green],[Green],[Red,Green,Red,Red,Green,Red,Green],[],[],[]]
	Left Game is still on course
Human turn: Right ()
	[[],[Green],[Red,Green],[Red,Green,Red,Red,Green,Red,Green],[],[],[]]
	Left Game is still on course
AI turn: Right ()
	[[Green],[Green],[Red,Green],[Red,Green,Red,Red,Green,Red,Green],[],[],[]]
	Right (WonBy Green)
Human turn: Left Game ended
	[[Green],[Green],[Red,Green],[Red,Green,Red,Red,Green,Red,Green],[],[],[]]
	Right (WonBy Green)
AI turn: Left Game ended
	[[Green],[Green],[Red,Green],[Red,Green,Red,Red,Green,Red,Green],[],[],[]]
	Right (WonBy Green)
		\end{lstlisting}
		\caption{Tutorial 2 - Log del partido contra \texttt{HFiaR.AI}}
		\label{tut212}
	\end{center}
\end{figure}
\paragraph{}Resta pues modificar la interfaz gr‡fica para que permita al usuario jugar contra la computadora, utilizando la funci—n \texttt{aiDropIn} en los turnos correspondientes a la m‡quina.  Para ello, F‡tima abre el m—dulo \texttt{HFiaR.GUI} y realiza los cambios pertinentes.   Se trata b‡sicamente de modificaciones de c—digo relacionado vinculado a \textsl{wxHaskell}, para las cuales \hpage\ no es de m‡s ayuda que en los ejemplos que hemos visto a lo largo de este tutorial.  Por ese motivo no los detallamos en este informe.  Para quien desee conocerlos puede encontrarlos en \htmladdnormallink{la p‡gina web del proyecto hfiar en github}{bihttp://github.com/elbrujohalcon/hfiar/commit/d69ab637bf32866e7e4550b6ea51cdd5fba33a90\#diff-2}~\cite{hfiar}
\paragraph{}El œltimo paso que F‡tima debe realizar es incluir su nuevo m—dulo en la lista de m—dulos de la librer’a \textsl{HFiaR} dentro del archivo \textbf{hfiar.cabal}.  Una vez hechas estas modificaciones, puede ejecutar los siguientes comandos y disfrutar de un partido de su juego favorito contra la computadora:
\lstset{language=sh, frame=single, tabsize=4}
\begin{center}\begin{lstlisting}
$ cabal configure --user
$ cabal build
$ cabal install
$ ~/.cabal/bin/hfiar &
\end{lstlisting}\end{center}

\newpage
\subsubsection{Conclusiones}
\paragraph{}A lo largo de este tutorial hemos podido ver c—mo utilizar \hpage\ para \textsl{comprender} c—digo \haskell\ a travŽs de \textsl{micro-testing}.  Hemos visto tambiŽn como, utilizando esa misma tŽcnica, podemos construir paso a paso m—dulos \haskell\ medianamente complejos.  Pudimos ver c—mo \hpage\ nos permite, al editar los m—dulos, recargarlos para volver a testearlos sin perder las expresiones que ya hab’amos definido.
\paragraph{}Hemos podido ver c—mo \hpage\ se encuentra integrado con \cabal\ para permitir cargar proyectos previamente configurados y evitar al desarrollador lidiar con el manejo de extensiones, carpetas y m—dulos manualmente.  Esto es una importante ventaja dado que la mayor’a de los proyectos desarrollados en \haskell\ se encuentran organizados en paquetes \cabal.  Pudimos observar tambiŽn c—mo \hpage\ se integra con \textsl{Hayoo!}, permitiendo al desarrollador consultar sus dudas sobre la API de \haskell\ directamente dentro de la aplicaci—n.
\paragraph{}Hemos visto c—mo utilizar \hpage\ para cargar o importar m—dulos y hemos notado las diferencias entre estas dos acciones.  TambiŽn hemos observado la forma gr‡fica con la que \hpage\ describe y permite navegar los m—dulos cargados o importados, sus funciones y sus estructuras de datos para luego utilizarlas en nuestro c—digo.
\paragraph{}Por otra parte, hemos podido trabajar con expresiones de entrada/salida con efectos colaterales (en otras palabras, expresiones de tipo \texttt{IO a}) y hemos visto como \hpage\ las ejecuta sin problemas, tal como lo hace \textsl{GHCi}.

\newpage
\subsection{Otras Caracter’sticas de \hpage}
\begin{epigraphs}
	\qitem{What is best in life?}{}
	\qitem{To crush your enemies, to see them driven before you, and to hear the lamentations of their women}{Conan, the Barbarian}
	\qitem{Hot water, good dentishtry and shoft lavatory paper}{Cohen, the Barbarian}
\end{epigraphs}
\paragraph{}Los dos tutoriales que hemos presentado en este cap’tulo muestran muchas de las principales caracter’sticas de \hpage.  Sin embargo, algunas otras caracter’sticas han quedado sin ser expuestas.  Es nuestra intenci—n utilizar esta secci—n para detallarlas, de modo que el usuario interesado pueda experimentar con ellas.

\label{secListas}\subsubsection{Listas}
\paragraph{}En el caso general, cuando el usuario desea interpretar una expresi—n \texttt{e}, si esta es de un tipo que es instancia de la clase \texttt{Show}, \hpage\ presenta al usuario el resultado de evaluar \texttt{show e}.  Ya hemos visto en el tutorial de la secci—n~\ref{secTut2} que las expresiones de tipo \texttt{IO a} son tratadas de un modo especial (son ejecutadas y se presenta al usuario el resultado de su ejecuci—n en caso de que sea de un tipo instancia de la clase \texttt{Show}).
\subparagraph{}Otras expresiones que son tratadas de un modo particular son las listas.  Cuando el usuario decide interpretar una expresi—n \texttt{e :: [a]} tal que \texttt{a} es instancia de \texttt{Show}, \hpage\ no evalœa \texttt{show e}, sino que intenta evaluar cada elemento de la lista en forma independiente y as’ presentarlo al usuario.  De ese modo, a pesar de que uno o m‡s de los elementos de la lista genere una excepci—n al intentar ser evaluado, los dem‡s elementos pueden ser mostrados al usuario y la interpretaci—n no se aborta.  La Figura~\ref{etc1}  nos ayudar‡ a entender mejor este concepto.  Cabe destacar que este comportamiento contempla tanto los casos en los que los elementos de la lista generen excepciones como aquellos en los que su c‡lculo implique un posible c—mputo infinito.  Dado que es imposible determinar cu‡ndo un c‡lculo es decididamente infinito, \hpage\ utiliza un mecanismo de \textsl{timeout}: Si pasado un segundo no se ha llegado a computar un valor, se muestra al elemento del mismo modo que se muestra a aquellos que generan excepciones. 
\begin{figure}[hp]
	\begin{center}
        	\includegraphics[width=.75\textwidth]{pictures/lists01}
		\caption{Interpretaci—n de listas}
		\label{etc1}
	\end{center}
\end{figure}
\subparagraph{}En la Figura~\ref{etc1} podemos ver que, al evaluar una lista en la que hay dos elementos que generan excepciones y uno que generar’a un c‡lculo infinito, \hpage\ nos presenta como su interpretaci—n el valor \texttt{[1, 2, $\bot$, $\bot$, $\bot$, 5]} y en la barra de estado nos informa que \textit{La expresi—n fue interpretada con errores} y podemos chequearlos \textit{clickeando con el bot—n derecho del mouse en cada uno de ellos}.  Al seleccionar el caracter \texttt{$\bot$} y hacer click con el bot—n derecho del mouse, se despliega el menœ contextual que podemos apreciar en la Figura~\ref{etc2}. Al presionar la opci—n \textsl{Explain}, \hpage\ nos presenta un cuadro de di‡logo explicando el error, como vemos en la Figura~\ref{etc3}.
\begin{figure}[hp]
	\begin{center}
        	\includegraphics[width=.75\textwidth]{pictures/lists02}
		\caption{Interpretaci—n de listas - Explicar}
		\label{etc2}
	\end{center}
\end{figure}
\begin{figure}[hp]
	\begin{center}
        	\includegraphics[width=.75\textwidth]{pictures/lists03}
		\caption{Interpretaci—n de listas - Explicaci—n}
		\label{etc3}
	\end{center}
\end{figure}

\clearpage
\newpage
\subsubsection{GŽnero}
\paragraph{}Otro caso de expresiones que son tratadas de un modo particular es el de las expresiones de tipo (como pueden ser \texttt{IO ()}, \texttt{Int} o \texttt{(Num n, Monad m) =>\ Float ->\ m [Float ->\ n]}).  En estos casos, \hpage\ entiende que el usuario al presionar el bot—n \textsl{Interpret} no quiere conocer el valor de la expresi—n sino m‡s bien el gŽnero (o, en inglŽs, \textsl{kind}) del tipo.  En \haskell\ cada tipo tiene un gŽnero asociado que puede ser utilizado para asegurar que el tipo es usado de modo correcto.  Las expresiones de tipos son clasificadas segœn sus gŽneros, los cuales pueden tomar una de las siguientes formas:
\begin{itemize}
	\item El s’mbolo \texttt{*} representa el gŽnero de tipos asociados con datos concretos.
	\item Si $k_{1}$ y $k_{2}$ son gŽneros, entonces $k_{1} \rightarrow k_{2}$ es el gŽnero de de los tipos que toman un tipo con gŽnero $k_{1}$ y devuelven un tipo con gŽnero $k_{2}$
\end{itemize}
\subparagraph{}Veamos como ejemplos las expresiones de las Figuras~\ref{etc4},~\ref{etc5} y~\ref{etc6}.
\begin{figure}[hp]
	\begin{center}
        	\includegraphics[width=.75\textwidth]{pictures/kind01}
		\caption{GŽneros - \texttt{IO ()}}
		\label{etc4}
	\end{center}
\end{figure}
\begin{figure}[hp]
	\begin{center}
        	\includegraphics[width=.75\textwidth]{pictures/kind02}
		\caption{GŽneros - \texttt{Int}}
		\label{etc5}
	\end{center}
\end{figure}
\begin{figure}[hp]
	\begin{center}
        	\includegraphics[width=.75\textwidth]{pictures/kind03}
		\caption{GŽneros - \texttt{(Num n, Monad m) =>\ Float ->\ m [Float ->\ n]}}
		\label{etc6}
	\end{center}
\end{figure}

\newpage
\subsubsection{Carga de M—dulos por Nombre}
\paragraph{}A lo largo de los tutoriales de este cap’tulo varias veces el usuario ha debido cargar m—dulos y siempre lo ha hecho seleccionando el archivo con el c—digo fuente del m—dulo que deseaba cargar.  \hpage\ brinda, adem‡s de esa forma, otra alternativa para la carga de m—dulos: cargarlos por su nombre.  Para ello, el usuario debe seleccionar la opci—n \textsl{Haskell $\rightarrow$ Load modules by name\ldots}.  El programa entonces le presentar‡ un cuadro de texto donde ingresar los nombres de los m—dulos que desea cargar separados por espacios.  \hpage, entonces, buscar‡ en primera instancia el c—digo precompilado de cada m—dulo e intentar‡ cargarlo junto con los m—dulos de los que depende.  De no ser posible, buscar‡ el c—digo fuente del mismo e intentar‡ compilarlo y cargarlo.  Para encontrar el c—digo fuente, \hpage\ intentar‡ ubicar el archivo correspondiente al m—dulo en primer lugar dentro de los directorios de archivos fuentes del paquete \cabal\ (si es que hay uno cargado) y luego en el directorio en el que se estŽ ejecutando la aplicaci—n.  Por ejemplo, en el caso de que no haya ningœn paquete cargado y se intente cargar el m—dulo \textbf{Test.Server}, \hpage\ intentar‡ cargar el archivo \textsl{./Test/Server.hs}.
\subsubsection{Configuraci—n del Compilador}
\paragraph{}Hemos mostrado en el tutorial de la Secci—n~\ref{secTut2} c—mo \hpage\ puede configurar su entorno y, sobre todo, las opciones necesarias para el compilador a partir de un paquete \cabal.  \hpage\ permite adem‡s al usuario modificar estas opciones a travŽs del menœ \textsl{Preferences...}.  Al seleccionar esta opci—n, \hpage\ presenta al usuario una ventana similar a la de la figura~\ref{etc7}.  En ella el usuario puede elegir las extensiones del lenguaje que desea habilitar, determinar las carpetas en las que el compilador puede ubicar los archivos con c—digo fuente y aplicar opciones al compilador.
\begin{figure}[hp]
	\begin{center}
        	\includegraphics[width=.75\textwidth]{pictures/prefs}
		\caption{Opciones del Compilador}
		\label{etc7}
	\end{center}
\end{figure}

\newpage
\section{Desarrollo - ?`C—mo se hizo \hpage?}
\subsection{Arquitectura General}
\begin{epigraphs}
	\qitem{If you think good architecture is expensive, try bad architecture}{Brian Foote and Joseph Yoder}
\end{epigraphs}
\paragraph{}Las principales decisiones de arquitectura que se tomaron durante el desarrollo de \hpage\ tuvieron como motivaciones los siguientes requerimientos:
\begin{description}
\item[Conexi—n con GHC] \hpage\ deb’a conectarse con el motor de GHC a travŽs de su API de modo de poder detectar e interpretar expresiones.  Para ello se utiliz— \htmladdnormallink{hint}{http://projects.haskell.org/hint}~\cite{hint}.  \textsl{hint} es una librer’a hecha en \haskell\ que provee una abstracci—n de alto nivel sobre la API de GHC.  Esta librer’a nos permite acceder de modo sencillo a las funciones provistas por la API y as’ poder evaluar expresiones, determinar su tipo y, en caso de expresiones de tipo, su gŽnero, cargar e importar m—dulos, utilizar extensiones del lenguaje y opciones del compilador.  \textsl{hint} provee funciones que permiten este manejo y pueden ser ejecutadas dentro de la m—nada \texttt{Interpreter}.
\item[Paralelismo] \hpage\ deb’a permitir al usuario editar sus p‡ginas mientras esperaba el resultado de la evaluaci—n de una expresi—n, detectar evaluaciones que podr’an ser infinitas y presentar la interpretaci—n de una expresi—n de manera incremental.  Todas estas tareas requieren la ejecuci—n de acciones en paralelo.  Para simplificar estas tareas, se cre— \textsl{eprocess} y se implement— un modelo de procesos utiliz‡ndolo.  En la Secci—n~\ref{secImplement} podremos observar en detalle c—mo ha sido desarrollada esta librer’a.
\item[Errores Controlados] \hpage\ no deb’a fallar si la evaluaci—n de una expresi—n fallaba.  M‡s aœn, tambiŽn deb’a detectar posibles evaluaciones infinitas e informar estas situaciones al usuario.  Aqu’ nuevamente entran en juego tanto \textsl{hint} como \textsl{eprocess}.
\item[Compatibilidad con GHCi] \hpage\ deb’a ser capaz de reemplazar a \textsl{GHCi} y, por lo tanto, brindar toda las funcionalidades que esta aplicaci—n brinda.  En particular, deb’a:
	\begin{itemize}
		\item ser multiplataforma
		\item detectar expresiones sint‡cticamente inv‡lidas
		\item identificar el tipo de cualquier expresi—n sint‡cticamente v‡lida
		\item identificar el gŽnero de cualquier tipo sint‡cticamente v‡lido
		\item interpretar expresiones de cualquier tipo, siempre que ese tipo sea instancia de la clase \textbf{Show}
		\item ejecutar e imprimir el resultado de expresiones de tipo \textbf{Show a $\Rightarrow$ IO a}
	\end{itemize}
\end{description}
\begin{figure}[hp]
	\begin{center}
        	\fbox{\includegraphics{pictures/architecture}}
		\caption{Arquitectura de \hpage}
		\label{arq1}
	\end{center}
\end{figure}
%%TODO: Modificar el dibujo:
%%		elementFiller -> elementFiller :: Process
%%		
\subparagraph{}Teniendo en cuenta estos requerimientos, la arquitectura resultante puede ser descripta con el diagrama de la Figura~\ref{arq1}.  Esta figura presenta el estado del sistema en un instante dado.  Cada bloque representa un proceso o ``thread'' en ejecuci—n.  Es importante no confundir estos \textsl{threads} con los threads del sistema operativo.  Los ``threads'' utilizados por \hpage\ son administrados por la m‡quina virtual de \textsl{GHC}.  Por este motivo, en un thread de sistema operativo pueden coexistir varios \textsl{threads} \haskell.
\subparagraph{}Cada uno de estos procesos se ejecuta dentro del entorno de una m—nada, la cual se encuentra identificada en la esquina superior derecha del bloque.  En el diagrama podemos identificar los siguientes componentes:
\begin{description}
	\item[UI Manager] Este es el thread que inicia el programa, genera y administra la interfaz del usuario utilizando las herramientas provistas por \textsl{wxHaskell}.  En este thread se mantiene el estado visual de la aplicaci—n: el estado de los controles, la œltima bœsqueda realizada, etc.
	\item[HPage Server] Este proceso, iniciado por el \textbf{UI Manager}, es el que comunica a la interfaz del usuario con la m‡quina virtual de \textsl{GHC}, a travŽs del \textbf{Hint Server}.  En el caso de expresiones de tipo \textbf{IO a}, este mismo proceso se comunica con el \textbf{IO Server} para ejecutarlas y obtener su resultado o capturar sus errores.  En este proceso se mantiene el estado general de la aplicaci—n: sus p‡ginas, expresiones, paquetes y m—dulos cargados, etc.  Este proceso permite la ejecuci—n de acciones definidas en la m—nada \texttt{HPage} de manera sincr—nica o asincr—nica.  En el caso de acciones ejecutadas asincr—nicamente, permite que las mismas sean canceladas.  En tales casos, dado que la API de \textsl{GHC} no provee un mecanismo para cancelar la acci—n en curso, \textbf{HPage Server} reinicia el \textbf{Hint Server} y se encarga de ``ponerlo al d’a'' aplicando las acciones necesarias para que se encuentre en el estado anterior a la ejecuci—n de la œltima acci—n.
	\item[IO Server]Este proceso, iniciado por el  \textbf{HPage Server}, es el encargado de ejecutar acciones de tipo \textbf{IO a} en un entorno controlado y obtener su resultado.
	\item[Hint Server] Este proceso, iniciado por el \textbf{HPage Server}, mantiene una conexi—n con la m‡quina virtual de GHC a travŽs de su API
	\item[Value Filler] Este proceso, iniciado por el \textbf{UI Manager} es el encargado de procesar el resultado obtenido del \textbf{HPage Server}.  Cabe recordar aqu’ que \haskell\ trabaja con evaluaci—n ``lazy'', por lo cual el resultado obtenido no ha sido aœn completamente procesado.  El \textbf{Value Filler} espera recibir un resultado y, al recibirlo, se encarga de evaluarlo y mostrarlo por pantalla, para ello intercambia mensajes con el \textbf{Element Filler} a fin de procesar cada porci—n del resultado a mostrar.  QuŽ constituye una \textsl{porci—n} depende del tipo de resultado.  Como hemos visto en la Secci—n \ref{secListas}, \hpage\ procesa de modo particular las listas.  En tales casos, a cada elemento de la lista se le aplica la funci—n \texttt{show} obteniendo un \texttt{String} que es enviado al \textbf{Element Filler} a fin de procesarlo por separado.  En otros casos, la funci—n \texttt{show} se aplica directamente a la expresi—n a interpretar y cada uno de los caracteres que componen la cadena es procesado por el \textbf{Element Filler}.  Explicaremos este proceso con m‡s detalle en las Secciones~\ref{secDesign}~y~\ref{secImplement}.
	\item[Element Filler] Este proceso, iniciado por el \textbf{UI Manager} cumple una muy sencilla funci—n: utilizando los procedimientos de env’o y recepci—n de mensajes provistos por \textsl{eprocess}, espera recibir una lista de caracteres (para ser precisos, espera recibir una expresi—n de tipo \texttt{String}), para evaluarla y enviar como respuesta su valor en forma normal.
	\item[Runaway Killer] Este thread, instancia del tipo \textsl{TimerEx} provisto por \textsl{wxHaskell}, es iniciado por el \textbf{Value Filler} al momento de enviar un nuevo elemento al \textbf{Element Filler}.  El objetivo del \textbf{Runaway Killer} es el de detectar procesamiento ``posiblemente'' infinito.  B‡sicamente, pasado un segundo de procesamiento, reinicia el \textbf{Element Filler} e informa al \textbf{Value Filler} que lo inici— que el elemento que se esperaba procesar ha demorado demasiado y podr’a desencadenar una evaluaci—n infinita.
\end{description}
\paragraph{}Para poder entender el funcionamiento de los distintos procesos con un mayor detalle, presentaremos un ejemplo en el cual el usuario define la expresi—n \texttt{e = let loop = loop in [1, loop, 3, div 0 0] ++ [5..]} e intenta interpretarla, pero, mientras \hpage\ est‡ present‡ndole los resultados, decide cancelar la interpretaci—n.  Elegimos la expresi—n \texttt{e} por ser una lista infinita y adem‡s presentar algunos elementos que generan distintos tipos de excepciones.  La Figura~\ref{seq1} nos muestra el diagrama de secuencia correspondiente al ejemplo.
%%TODO: Modificar el dibujo:
%%		elementFiller -> elementFiller :: Process
%%		ahora anda como WIC!!
\begin{figure}[hp]
	\begin{center}
        	\fbox{\includegraphics[width=\textwidth]{pictures/sequence}}
		\caption{Secuencia de Evaluaci—n de \texttt{e = let loop = loop in [1, loop, 3, div 0 0] ++ [5, ..]}}
		\label{seq1}
	\end{center}
\end{figure}
\subparagraph{}Podemos ver en el diagrama que el \textbf{HPage Server}, al detectar que la expresi—n a evaluar es una lista, en lugar de solicitar al \textbf{Hint Server} que evalœe la expresi—n original, le solicita la interpretaci—n de la expresi—n \texttt{map show e}, de modo de obtener una lista de \texttt{String}s para retornar al \textbf{UI Manager}.  Luego, el \textbf{Value Filler}, al recibir una lista de valores a mostrar, intenta presentar cada uno de ellos por separado, concaten‡ndolos del modo en que generalmente se presentan las listas en \haskell.  Cuando el usuario decide cancelar, \textbf{HPage Server} detiene el \textbf{Value Filler} y, por lo tanto, este proceso se interrumpe.
\subparagraph{}Con el objetivo de destacar otras interacciones m‡s significativas, en el diagrama de la Figura~\ref{seq1} hemos omitido la parte del proceso que involucra al \textbf{Element Filler} y al \textbf{Runaway Killer}.  Para visualizar mejor su utilidad, la Figura~\ref{seq2} nos muestra en detalle lo que sucede cuando se intentan presentar los dos primeros elementos de la lista.  Como puede verse, al intentar mostrar la expresi—n \texttt{e}, \hpage\ se encontrar‡ con una lista cuyo segundo elemento no puede computar pues requiere un c‡lculo infinito, en la Figura~\ref{seq2} representamos este caracter con la letra $\Omega$. All’ es donde entra en acci—n el \textbf{Runaway Killer} para informar esta situaci—n al usuario.
%%TODO: Modificar el dibujo:
%%		elementFiller -> elementFiller :: Process
%%		ahora son elementos y no est‡ m‡s WIC
\begin{figure}[hp]
	\begin{center}
        	\fbox{\includegraphics[width=\textwidth]{pictures/sequence2}}
		\caption{Detalle de Secuencia de Evaluaci—n de \texttt{e}}
		\label{seq2}
	\end{center}
\end{figure}

\newpage
\label{secDesign}\subsection{Dise–o}
\begin{epigraphs}
	\qitem{Design and programming are human activities; forget that and all is lost}{Bjarne Stroustrup}
\end{epigraphs}
\paragraph{}Presentaremos a continuaci—n las principales decisiones de dise–o que se han tomado durante la creaci—n de \hpage.  Todas ellas tienen como fundamento los requerimientos principales exhibidos en la secci—n anterior y tambiŽn algunos requerimientos adicionales, como la integraci—n con \cabal\ y \textsl{Hayoo!}.
\subsubsection{Concurrencia}
\paragraph{}Como hemos visto en la secci—n anterior, al momento de dise–ar \hpage\ tuvimos que considerar la necesidad de paralelizar tareas, para permitir al usuario, por ejemplo, trabajar en un documento mientras el motor de \hpage\ evalœa una expresi—n.  TambiŽn debemos considerar que estas tareas a realizar en paralelo no son totalmente independientes sino que requieren una sincronizaci—n.  Tomando la idea del modo en que est‡ dise–ado el lenguaje de programaci—n \textsl{Erlang}, decidimos implementar el paralelismo utilizando lo que denominamos \textsl{procesos}.  Conceptualmente, los \textsl{procesos} son hilos de ejecuci—n que se realizan en paralelo y pueden recibir o enviar mensajes.   Esta caracter’stica de mensajer’a entre procesos es la que permite la sincron’a cuando es necesaria.  Por otra parte, a diferencia de \textsl{Erlang}, al utilizar \haskell, los mensajes enviados de un proceso a otro pueden ser mucho m‡s complejos.  Gracias al hecho de que en \haskell\ las acciones son elementos de primer orden, un proceso puede enviar a otro directamente las acciones que desea que Žste ejecute, tal como deben ser ejecutadas.  Esta es una caracter’stica esencial para reducir la complejidad de la implementaci—n de todos nuestros procesos, en particular de aquellos que actœan como servidores (\textbf{IO Server}, \textbf{HPage Server} y \textbf{Hint Server}), como veremos luego en la Secci—n~\ref{secImplement}.
\subsubsection{Bottoms}\label{secBottoms}
\paragraph{}El lenguaje \haskell\ tiene una caracter’stica œnica: \textsl{la evaluaci—n perezosa} o \textsl{lazy evaluation}.  Gracias a esta caracter’stica, las expresiones \haskell\ no son completamente evaluadas (reducidas a forma normal) hasta el momento en que realmente se necesita conocer su valor.  Dado que \hpage\ presenta al usuario un interprete de expresiones, es necesario que estŽ preparado para no s—lo soportar sino tambiŽn aprovechar esta caracter’stica.  En particular, dentro de \hpage\ las expresiones son reducidas a forma normal al momento de intentar mostrar el resultado de su evaluaci—n al usuario.  En ese momento, \hpage\ distingue cuatro tipos de valores:
\begin{description}
	\item[Entrada/Salida] Expresiones cuyo valor es de tipo \texttt{IO a}, donde \texttt{a} es un tipo que es instancia de la clase \texttt{Show}.  En este caso, \hpage\ intentar‡ ejecutar la acci—n, obtener su resultado y presentarlo al usuario como se ver‡ a continuaci—n.
	\item[Listas] Expresiones cuyo valor es de tipo \texttt{[a]} (o sea, listas con elementos de tipo \texttt{a}), donde \texttt{a} es un tipo que es instancia de la clase \texttt{Show}.  En este caso, \hpage\ intenta reducir cada elemento e ir present‡ndolo al usuario dentro de una lista.  Durante este proceso, pueden suceder varias cosas:
		\begin{itemize}
			\item Por supuesto, puede suceder que al evaluar un elemento se obtenga una cadena de caracteres, en cuyo caso \hpage\ simplemente presentar‡ el resultado al usuario y continuar‡ evaluando el resto de la lista.
			\item Puede suceder tambiŽn que, intentando evaluar un elemento, se genere un c‡lculo ``infinito'' o una excepci—n.  En estos casos, \hpage\ informa la situaci—n al usuario y aborta esa evaluaci—n para continuar con el siguiente elemento.
			\item Otra posibilidad es que, luego de presentar un elemento, al intentar obtener el resto de la lista, \hpage\ encuentre un c‡lculo ``infinito''.  En estos casos, \hpage\ permite al usuario cancelar la evaluaci—n cuando lo considere apropiado.
			\item Por œltimo, es posible que, luego de presentar un elemento, al intentar obtener el resto de la lista, \hpage\ encuentre una excepci—n.  En estos casos, \hpage\ informa la situaci—n al usuario y aborta la evaluaci—n de la expresi—n.
		\end{itemize}
	\item[Expresiones ``visibles''] Expresiones cuyo tipo es instancia de la clase \texttt{Show}.  \hpage\ intenta evaluar la expresi—n a mostrar y, al igual que en el caso anterior, nos podemos encontrar con varios casos:
		\begin{itemize}
			\item Al igual que en el caso de las listas lo esperado es que al evaluar la expresi—n se obtenga una cadena de caracteres, en cuyo caso \hpage\ simplemente presentar‡ el resultado al usuario.
			\item Puede suceder que, intentando evaluar la expresi—n se obtenga una cadena de caracteres de longitud infinita.  La pol’tica de \hpage\ en este caso es permitir al usuario decidir cu‡ndo desea abortar la evaluaci—n y mostrar la porci—n del resultado obtenida hasta ese momento
			\item Puede suceder tambiŽn que, intentando evaluar un caracter, se genere un c‡lculo ``infinito'' o una excepci—n.  En este caso tambiŽn, \hpage\ permite al usuario cancelar la evaluaci—n cuando lo considere apropiado.
			\item Otra posibilidad es que, luego de presentar un caracter, al intentar obtener el resto de la cadena, \hpage\ encuentre un c‡lculo ``infinito''.  En estos casos, nuevamente \hpage\ permite al usuario cancelar la evaluaci—n cuando lo considere apropiado.
			\item Por œltimo, es posible que, luego de presentar un caracter, al intentar obtener el resto de la cadena, \hpage\ encuentre una excepci—n.  En estos casos, \hpage\ informa la situaci—n al usuario y aborta la evaluaci—n de la expresi—n.
		\end{itemize}
	\item[Expresiones no ``visibles''] Expresiones cuyo tipo no es instancia de la clase \texttt{Show}.  \hpage\, ante estas expresiones, se limita a mostrar su tipo.
\end{description}
\subparagraph{}La distinci—n que hace \hpage\ ante los distintos tipos de expresiones  a procesar y el comportamiento escogido al momento de mostrar el resultado de su evaluaci—n tienen como objetivo brindar al usuario la mayor cantidad de informaci—n posible sobre la expresi—n que desea interpretar.  Sin ellos, el comportamiento natural de un programa como \hpage\ ante una expresi—n \texttt{e}, ser’a el de asignar el resultado de \texttt{show e} al cuadro de texto que presenta el resultado al usuario.
\subparagraph{}En el caso de las acciones de entrada/salida, \hpage\ al igual que \textsl{GHCi}, considera que el usuario no est‡ simplemente interesado en conocer el tipo de las acciones, sino en ejecutarlas para producir (de ser preciso) ciertos efectos secundarios y obtener un resultado.  Es razonable pensar que quien construye una acci—n de este tipo (que no es instancia de la clase \texttt{Show}) pero que produce (al ser evaluada) un resultado de un tipo que s’ lo es, est‡ interesado en ejecutar la acci—n y obtener el resultado.
\subparagraph{}En otro caso, veamos con un ejemplo, quŽ suceder’a si \hpage\ asignase directamente el resultado de \texttt{show e} al cuadro de texto.  Para nuestro ejemplo, vamos a utilizar una expresi—n similar a la del diagrama de secuencia de la Figura~\ref{seq2} que nos va a permitir mostrar todos los casos posibles:
\begin{center}\begin{lstlisting}
let infinite = [4..] in
	let loop = loop in
		[1, undefined, 2, div 0 0, 3, loop] ++ infinite
\end{lstlisting}\end{center}
\subparagraph{}Si el usuario quisiese interpretar la expresi—n \texttt{infinite} y \hpage\ intentase asignar su valor (\texttt{[4..]}) al cuadro de texto, har’a falta reducir a forma normal una lista infinita, c‡lculo que nunca terminar’a y por tanto, el usuario no ver’a ningœn resultado en la pantalla.
\subparagraph{}Si, en su lugar, el usuario quisiese interpretar la expresi—n completa, el intŽrprete generar’a una excepci—n \texttt{Prelude.undefined} al intentar mostrar el segundo elemento de la lista y esa excepci—n ser’a todo lo que el usuario podr’a saber sobre la evaluaci—n de su expresi—n.
\subparagraph{}Entonces, en vez de asignarlo directamente, \hpage\ podr’a evaluar la expresi—n caracter a caracter e ir presentando cada uno de ellos al usuario a medida que los va obteniendo.  En ese caso, los caracteres correspondientes al primer elemento de la lista (\texttt{[1,}) podr’an ser mostrados al usuario pero, al llegar al segundo, nuevamente el intŽrprete generar’a la excepci—n y ya ningœn otro elemento de la lista podr’a ser mostrado.  Aproximadamente de este modo es como se comportan tanto \textsl{GHCi} como \textsl{Hugs98}.
\subparagraph{}Al dise–ar \hpage\ decidimos intentar dar un resultado aœn m‡s completo.  Para ello, \hpage\ puede detectar que la expresi—n a evaluar tiene tipo \texttt{[Int]} y, por lo tanto se trata de una lista cuyos elementos son de un tipo que es instancia de la clase \texttt{Show}.  \hpage\ \textsl{``sabe''} c—mo se representan las listas y, por lo tanto, puede emular el comportamiento de \texttt{show} en esos casos.  Lo que \hpage\ puede hacer pues es intentar aplicar \texttt{show} a cada elemento por separado, mostrar (de modo an‡logo a como se presentan las listas) aquellos que efectivamente puedan ser evaluados y exhibir de otro modo aquellos que no.  Para estos casos, en los que por algœn motivo, un elemento no puede ser mostrado, hemos elegido presentar el caracter $\bot$ y permitir al usuario, a travŽs de un menœ contextual saber por quŽ no se ha podido mostrar el elemento.  En nuestro ejemplo, con esta modalidad, \hpage\ presentar’a al usuario una lista que comenzar’a con \texttt{[1, $\bot$, 2, $\bot$, 3,} y, al llegar al sexto elemento, dado que el intŽrprete deber’a resolver un c‡lculo infinito para presentar el siguiente elemento, dejar’a de presentar resultados y el usuario no tendr’a otra alternativa que presionar el bot—n \textsl{Cancel} para detener la ejecuci—n.
\subparagraph{}La versi—n actual de \hpage\ tiene en cuenta estos casos de c‡lculos infinitos y, por ello, al ir evaluando elemento por elemento, verifica que ninguno de ellos requiera m‡s de un segundo en ser calculado.  En caso de demorar m‡s que ello, \hpage\ introducir‡ el caracter  $\bot$ y, por lo tanto, presentar‡ al usuario la lista, en principio, infinita que comienza con \texttt{[1, $\bot$, 2, $\bot$, 3, $\bot$, 4, 5, 6, \ldots}
\subparagraph{}De este modo, \hpage\ intenta mostrar al usuario tanta informaci—n como sea posible sobre la expresi—n que se quiere interpretar.  Est‡ claro que, si bien son probablemente los m‡s habituales, las acciones de entrada/salida y las listas son s—lo dos casos especiales de un gran conjunto de tipos de expresiones cuya interpretaci—n puede ser presentada de modo de brindar mayor informaci—n que la que brinda la evaluaci—n directa de \texttt{show}.  Nos explayaremos m‡s sobre este tema y sobre c—mo \hpage\ podr’a adaptarse para contemplar otros casos en la Secci—n~\ref{secTaR}.

\subsubsection{Integraci—n}
\paragraph{}Una de las herramientas m‡s comœnmente usadas por los desarrolladores haskell es \cabal.  En un \textsl{paquete Cabal}, el desarrollador define los m—dulos que componen su aplicaci—n o librer’a, los lugares (carpetas) d—nde encontrar el c—digo fuente y los recursos que Žstos necesitan para funcionar, junto con las extensiones que se requieren para poder compilarlos.
\subparagraph{}\hpage\ por su parte, permite al desarrollador cargar o importar m—dulos para poder utilizarlos al momento de evaluar expresiones.  TambiŽn permite definir los lugares donde el compilador puede encontrar archivos fuentes y las extensiones que Žste debe utilizar al momento de compilar los archivos encontrados.
\subparagraph{}Observando estas similitudes, una integraci—n con \cabal\ es algo que surge de manera natural y \hpage\ lo provee.  \hpage\ permite al desarrollador cargar un paquete \cabal\ previamente configurado y de ese modo utilizar los m—dulos, extensiones y ubicaciones en Žl definidos.
\paragraph{}Otra herramienta, quiz‡ no tan popular como \cabal, pero tambiŽn muy œtil es \textsl{Hayoo!}.  Conociendo esta herramienta, decidimos integrarla con \hpage\ de modo que el desarrollador pueda realizar consultas en su base de datos para obtener informaci—n sobre alguna funci—n, tipo, m—dulo, clase o expresi—n que desee analizar.

\newpage
\subsection{Implementaci—n}\label{secImplement}
\begin{epigraphs}
	\qitem{Nothing resolves design issues like an implementation}{J. D. Horton}
	\qitem{A child of five would understand this. Send someone to fetch a child of five}{Groucho Marx}
\end{epigraphs}

\subsubsection{eprocess}\label{secEprocess}
\paragraph{}Para la implementaci—n de \textsl{eprocess}, nuestra librer’a de procesos, utilizamos varias herramientas de paralelismo y concurrencia que se encuentran muy bien descriptas en el libro \htmladdnormallink{Real World Haskell}{http://book.realworldhaskell.org/read/concurrent-and-multicore-programming.html}~\cite{realworldhaskell}.  Utilizamos \textsl{Threads} para paralelizar procesos y \textsl{Channels} y \textsl{MVars} para permitirles comunicarse.
\subparagraph{}Un \textsl{Thread} es una acci—n de entrada/salida que se ejecuta de manera independiente.  Para crear un \textsl{Thread}, se debe importar el m—dulo \texttt{Control.Concurrent} y utilizar la funci—n \texttt{forkIO}.
\subparagraph{}Una \textsl{MVar} representa una \textit{caja para un œnico elemento}: puede estar llena o vac’a.  Podemos poner algo en la caja, llen‡ndola, o sacarlo, vaci‡ndola.  Si intentamos poner algo en una \textsl{MVar} que ya est‡ llena, nuestro \textsl{Thread} quedar‡ bloqueado hasta que otro tome su contenido y, por ende, la vac’e.  Del mismo modo, si intentamos tomar el valor de una \textsl{MVar} que est‡ vac’a, nuestro \textsl{Thread} esperar‡ hasta que alguien ponga un valor en ella.
\subparagraph{}Finalmente, un \textsl{Channel} es una abstracci—n de una v’a de comunicaci—n unidireccional o, visto de otro modo, una cola de mensajes.  Siempre se puede agregar un nuevo mensaje a un canal sin bloquear el \textsl{Thread} que escribe.  Sin embargo, si el canal est‡ vac’o, el \textsl{Thread} que intente leer se bloquear‡ hasta que llegue el primer valor.
\subparagraph{}Con estos elementos, definimos entonces un tipo mon‡dico para representar a las acciones a realizarse en procesos paralelos de tipo \texttt{m}, tales que retornan expresiones de tipo \texttt{a} y pueden recibir elementos de tipo \texttt{r}:
\begin{center}\begin{lstlisting}
newtype ReceiverT r m a = RT { internalReader :: ReaderT (Handle r) m a }
    deriving (Monad, MonadIO, MonadTrans, MonadCatchIO)
\end{lstlisting}\end{center}
\subparagraph{}Individualizamos luego este tipo genŽrico, definiendo el tipo \texttt{Process}:
\begin{center}\begin{lstlisting}
type Process r = ReceiverT r IO
\end{lstlisting}\end{center}
\subparagraph{}Finalmente definimos las funciones que permiten la ejecuci—n y mensajer’a entre procesos:
\begin{center}\begin{lstlisting}
spawn :: MonadIO m => Process r k -> m (Handle r)
kill :: MonadIO m => Handle a -> m ()
self :: Monad m => ReceiverT r m (Handle r)
sendTo :: MonadIO m => Handle a -> a -> m ()
recv :: MonadIO m => ReceiverT r m r
\end{lstlisting}\end{center}
\subparagraph{}Las funciones \texttt{spawn} y \texttt{kill} inician y detienen un proceso respectivamente.  \texttt{spawn} retorna como resultado un \texttt{Handle}, que identifica un’vocamente al proceso y permite enviarle mensajes utilizando la funci—n \texttt{sendTo}.  Cabe notar que esta funci—n no necesita ser utilizada dentro de un \textsl{process} sino simplemente en cualquier instancia de la clase \texttt{MonadIO}.  De este modo, el \textsl{thread} que haya ejecutado \texttt{spawn} puede ejecutar \texttt{sendTo} para enviar mensajes al proceso que ha iniciado.
\subparagraph{}Luego, dentro de una instancia de \texttt{ReceiverT} se puede utilizar la funci—n \texttt{self} para conocer el propio \texttt{Handle} y \texttt{recv} para recibir mensajes.  Cabe notar que \texttt{recv} se ejecuta de manera bloqueante, emulando el comportamiento de la funci—n \texttt{receive} de \textsl{Erlang}.  Sin embargo, a diferencia de \textsl{Erlang}, el tipado est‡tico de \haskell\ permite garantizar en tiempo de compilaci—n que ningœn proceso reciba un mensaje que no est‡ esperando.   Para notar esto basta observar que en el tipo de la funci—n \texttt{sendTo} el par‡metro del tipo \texttt{Handle} que indica el tipo de mensajes que espera recibir el proceso y el tipo del mensaje a enviar deben coincidir.

\newpage
\subsubsection{Servers}
\paragraph{}Con el objetivo de separar la interacci—n con GHC del resto de la ejecuci—n del sistema y de esta manera, poder capturar sus excepciones y aislarlas, hemos encapsulado la ejecuci—n de estas acciones (correspondientes a la m—nada \texttt{Interpreter}) en un proceso particular, al que denominamos \textbf{Hint Server}.  Por otra parte, con objetivos similares, decidimos aislar la ejecuci—n de las acciones propias de \hpage\ (correspondientes a la m—nada \texttt{HPage}) de las relativas a la interfaz de usuario, para lo cual creamos el proceso \textbf{HPage Server}.  A su vez, tambiŽn fue necesario ejecutar acciones de la m—nada \texttt{IO} en un contexto controlado, por lo que desarrollamos el proceso \textbf{IO Server}.  Gracias al uso de m—nadas, al hecho de que las acciones sean objetos de primer tipo y a los mecanismos provistos por \textsl{eprocess}, pudimos construir estos servers de una manera sencilla.   Mostramos, a modo de ejemplo, el c—digo del \textbf{IO Server}:
\begin{center}\begin{lstlisting}
module HPage.IOServer (start, stop, runIn, ServerHandle) where

import Control.Exception (try, SomeException)
import Control.Monad
import Control.Monad.Trans
import Control.Concurrent.Process

newtype ServerHandle = SH {handle :: Handle (IO ())}

start :: IO ServerHandle
start = spawn ioRunner >>= return . SH
    where ioRunner = forever $ recv >>= liftIO

runIn :: ServerHandle -> IO a -> IO (Either SomeException a)
runIn server action = runHere $ do
                                    me <- self
                                    sendTo (handle server) $ try action >>=
                                                                    sendTo me
                                    recv
stop :: ServerHandle -> IO ()
stop = kill . handle
\end{lstlisting}\end{center}
\subparagraph{}Cabe destacar la simpleza de este m—dulo que, con no m‡s de 20 l’neas de c—digo es capaz de ejecutar cualquier acci—n dentro de la m—nada \texttt{IO} en un proceso aislado y controlado.
\subparagraph{}Para entender el comportamiento de este m—dulo, iremos paso a paso:
\subparagraph{Imports} Al inicio del m—dulo se realiza la importaci—n de los siguientes m—dulos auxiliares:
\begin{description}
	\item[\texttt{Control.Exception}] Se importan la funci—n \texttt{try} para poder capturar las excepciones que se generen durante la ejecuci—n de las acciones y el constructor \texttt{SomeException} pues es el constructor del tipo de excepci—n m‡s genŽrico, el mismo engloba a todos los dem‡s.  Nuestro objetivo es poder capturar cualquier excepci—n que se genere durante la ejecuci—n de una acci—n.
	\item[\texttt{Control.Monad}] Se importa el m—dulo para poder utilizar las funciones \texttt{$>>$} y \texttt{$>>=$} que permitir‡n concatenar acciones, la funci—n \texttt{return} para determinar expl’citamente el resultado de una acci—n y la funci—n \texttt{forever} que explicaremos m‡s adelante.
	\item[\texttt{Control.Monad.Trans}] Se importa el m—dulo para poder combinar acciones de tipo \texttt{Process} con acciones de tipo \texttt{IO a} utilizando la funci—n \texttt{liftIO}
	\item[\texttt{Control.Concurrent.Process}] Este es el m—dulo en el que se encuentran definidas las funciones de la librer’a \textsl{eprocess}
\end{description}
\subparagraph{ServerHandle}Luego se define el tipo \texttt{ServerHandle}, cuyas instancias representan identificadores un’vocos de \textsl{IO Servers}.  El proceso que inicie un servidor obtendr‡ un \texttt{ServerHandle} que le permitir‡ comunicarse con Žl.
\subparagraph{start}A continuaci—n se define la funci—n que inicia el servidor y retorna su \texttt{ServerHandle}.  El servidor es iniciado utilizando la funci—n \texttt{spawn} provista por \textsl{eprocess}, la cual retorna un \texttt{Handle} que es encapsulado en un \texttt{ServerHandle} utilizando su constructor \texttt{SH}.  La funci—n \texttt{spawn} toma como primer par‡metro la acci—n (de tipo \texttt{Process}) que se ejecutar‡ en el nuevo proceso.  En este caso, esa acci—n recibe el nombre de \texttt{ioRunner} y se define utilizando la funci—n \texttt{forever} que ejecuta, en principio, indefinidamente la acci—n que recibe por par‡metro.  En nuestro caso, la acci—n a ejecutar indefinidamente es \texttt{recv $>>=$ liftIO}, la cual puede leerse como ``esperar a recibir un valor y, una vez recibido, aplicarle la funci—n \texttt{liftIO}''.  Esta funci—n permite ejecutar acciones de tipo \texttt{IO a} dentro del contexto de otra m—nada, en este caso \texttt{Process a}.
\subparagraph{runIn} La siguiente funci—n que aparece en el m—dulo es \texttt{runIn}, una funci—n pensada para ejecutar acciones.  Esta funci—n toma como par‡metro un \texttt{ServerHandle} y una acci—n (de tipo \texttt{IO a}), compone una nueva acci—n (de tipo \texttt{IO ()} que consiste en intentar evaluar la acci—n recibida y luego enviar el resultado de la misma nuevamente al proceso en el que se est‡ evaluando \texttt{runIn}), env’a esta nueva acci—n al servidor correspondiente al \texttt{ServerHandle} recibido y se bloquea esperando el resultado.  Observemos en detalle las funciones involucradas en este proceso:
\begin{description}
	\item[\texttt{runHere}] Esta funci—n permite ejecutar acciones de tipo \texttt{Process a} en el contexto de la m—nada \texttt{IO}.
	\item[\texttt{self}] Como hemos visto en la secci—n~\ref{secEprocess}, esta funci—n nos permite conocer el \texttt{Handle} del propio proceso.
	\item[\texttt{sendTo}] Utilizando esta funci—n se env’a a un proceso un mensaje, en este caso la acci—n modificada que se espera ejecute.
	\item[\texttt{handle}] Esta funci—n, definida de forma impl’cita en el constructor del tipo \texttt{ServerHandle} nos devuelve el \texttt{Handle} del mismo, que es lo que \texttt{sendTo} necesita para ``ubicar'' al proceso al que debe enviar el mensaje.
	\item[\texttt{try}] Esta funci—n intenta ejecutar una acci—n y devuelve, en caso de detectar una excepci—n, la expresi—n \texttt{Left e} donde \texttt{e} es la excepci—n capturada y, en caso de que la acci—n se ejecute correctamente, la expresi—n \texttt{Right a} donde \texttt{a} es el resultado de la acci—n.
	\item[\texttt{$>>=$}] Esta funci—n toma una acci—n de algœn tipo que sea instancia de la clase \texttt{Control.Monad} y una funci—n y genera una nueva acci—n que consiste en evaluar la primera, luego construir un nueva acci—n utilizando la funci—n con el resultado obtenido como par‡metro y finalmente ejecutar esta segunda acci—n.  En nuestro caso, la utilizamos para que el servidor (usando \texttt{sendTo me}) env’e al proceso ejecutado con \texttt{runHere} el resultado de \texttt{try action}.
	\item[\texttt{recv}] Como hemos visto en la secci—n~\ref{secEprocess}, esta funci—n bloquea al proceso en espera de recibir algœn mensaje y retorna ese mensaje una vez recibido.
\end{description}
\subparagraph{stop} La œltima de las funciones simplemente compone las funciones \texttt{handle} (nos devuelve el \texttt{Handle} del servidor) con \texttt{kill} que, como hemos visto en la secci—n~\ref{secEprocess}, lo detiene.

\subsubsection{M—dulos de \hpage}
\paragraph{}El m—dulo principal de la aplicaci—n es el denominado \texttt{HPage.Control}.  Este m—dulo describe la m—nada \texttt{HPage} e incluye todas las acciones que pueden realizarse en ella.  Es el encargado de mantener el estado del sistema, para lo cual hemos definido un tipo de datos llamado \texttt{Context}, que mostraremos a continuaci—n.
\begin{center}\begin{lstlisting}
newtype Expression = Exp {exprText :: String}       
    deriving (Eq, Show)

data Page = Page { -- Display --
                   expressions :: [Expression],
                   currentExpr :: Int,
                   undoActions :: [HPage ()],
                   redoActions :: [HPage ()],
                   -- File System --
                   original :: [Expression],
                   filePath    :: Maybe FilePath
                  }
                  
data Context = Context { -- Package --
                         activePackage :: Maybe PackageIdentifier,
                         pkgModules :: [Hint.ModuleName],
                         -- Pages --
                         pages :: [Page],
                         currentPage :: Int,
                         -- GHC State --
                         loadedModules :: Set String,
                         importedModules :: Set String,
                         extraSrcDirs :: [FilePath],
                         ghcOptions :: String,
                         server :: HS.ServerHandle,
                         ioServer :: HPIO.ServerHandle,
                         -- Actions --
                         recoveryLog :: Hint.InterpreterT IO ()
                       }
\end{lstlisting}\end{center}

\subparagraph{} Los principales componentes del estado del sistema son:
\begin{description}
	\item[activePackage] El paquete \cabal\ activo, si es que se ha cargado alguno.
	\item[pages] Las p‡ginas que el usuario est‡ viendo.  Cabe notar que un usuario puede tener varias p‡ginas activas a la vez, una con cada documento.
	\item[loadedModules / importedModules] Los m—dulos que el usuario ha cargado / importado
	\item[server] El handle del \textbf{Hint Server} que el mismo \textbf{HPage Server} inicia y mantiene
	\item[ioServer] El handle del \textbf{IO Server} que el mismo \textbf{HPage Server} inicia y mantiene
	\item[recoveryLog] El log de acciones realizadas hasta el momento, necesario al momento de detener el \textbf{Hint Server}.  Cabe destacar aqu’ c—mo se construye este log: Se trata de una œnica acci—n de tipo \texttt{Hint.InterpreterT IO ()} que se va construyendo de manera incremental al realizar cada acci—n que involucre a \texttt{Hint} en la m—nada \texttt{HPage}.  Cuando una acci—n es aplicada (o sea, al momento en que ya finaliz— su ejecuci—n -recordemos que \texttt{HPage.Control} permite ejecutar acciones de manera sincr—nica o asincr—nica-), se ejecuta el siguiente c—digo para agregarla al log (donde \texttt{c} es el contexto actual, \texttt{ra} es la acci—n ejecutada y el resultado es el nuevo contexto actual, una vez almacenada la acci—n):
\begin{center}\begin{lstlisting}
c{recoveryLog  = (recoveryLog c) >> ra >> return ()}
\end{lstlisting}\end{center}
\end{description}

\subparagraph{}N—tese que el paquete \cabal, las extensiones y los m—dulos cargados o importados, etc. son independientes de las p‡ginas con las que el usuario estŽ trabajando, por lo que el usuario por ejemplo no puede manejar dos paquetes \cabal\ a la vez.  ƒsto se debe a que la API de \textsl{GHC} no permite la utilizaci—n de \textsl{multi-threading}, por lo tanto, dentro de un programa s—lo puede haber una œnica lista de m—dulos cargados/importados, una œnica lista de extensiones, etc.
\subparagraph{}TambiŽn debe notarse que mucha de la informaci—n de estado guardada en el \texttt{Context} es ``redundante'' pues se configura directamente en el \textbf{Hint Server}.  Eso se debe a que ante la necesidad de reiniciarlo, el \textbf{HPage Server} restaura su estado utilizando esos datos.
\subparagraph{}Finalmente, \texttt{recoveryLog} se utiliza para permitir al usuario cancelar acciones que intenta ejecutar de modo asincr—nico.  Cada acci—n que se desea realizar de forma asincr—nica, devuelve una \textsl{MVar} que se llenar‡ en caso de finalizar la acci—n con Žxito y se acumular‡ en el \texttt{recoveryLog}.  En caso de que el usuario decida cancelar, el \textbf{HPage Server} reiniciar‡ el \textbf{IO Server} y el \textbf{Hint Server}, configurar‡ a este œltimo segœn los dem‡s par‡metros (ej: \texttt{ghcOptions}) y ejecutar‡ \texttt{recoveryLog} para ``ponerlo al d’a''.
\subparagraph{}El estado de las p‡ginas con las que el usuario trabaja est‡ definido como una lista de expresiones y dos listas de acciones para permitir el uso de \textsl{undo} y \textsl{redo}.  Finalmente, si la p‡gina corresponde a un archivo en disco, \hpage\ identifica el ``path'' del mismo para poder guardarlo o recargarlo de ser necesario.
\subparagraph{}Gracias a haber separado la l—gica correspondiente a la interfaz de usuario y la propia de \hpage, hemos podido desarrollar esta œltima utilizando la tŽcnica de TDD (Test Driven Development) ~\cite{tdd}.  Para ello utilizamos \htmladdnormallink{QuickCheck}{http://www.cs.chalmers.se/~rjmh/QuickCheck/}~\cite{quickcheck}, una herramienta de testeo autom‡tico para programas \haskell\ que nos permiti— ir desarrollando y verificando tests de manera incremental hasta alcanzar la actual definici—n del \textbf{HPage Server}.  Los tests desarrollados pueden ser ejecutados utilizando el siguiente comando:
\lstset{language=sh, frame=single, tabsize=2}
\begin{center}\begin{lstlisting}
$ cabal test hpage
\end{lstlisting}\end{center}
\lstset{language=haskell, frame=single, tabsize=4}

\subsubsection{UI}
\paragraph{}La interfaz gr‡fica de \hpage\ est‡ desarrollada utilizando \textsl{wxHaskell}, un framework elegido por ser multi-plataforma y, gracias a estar construido sobre \textsl{wxWidgets}, presentar un ``look\&feel'' nativo en distintos entornos.  \textsl{wxHaskell} es un framework sencillo para utilizar y entender y, pese a que aœn se encuentra en per’odo de evoluci—n, es suficientemente estable.  Sin embargo, tal como puede verse en \textsl{wxhNotepad} hemos tenido que superar varios escollos hasta lograr una UI estable e intuitiva.  A los lectores interesados en estos detalles tŽcnicos les recomendamos los art’culos escritos por Jeremy O'Donoghue en su tutorial \htmladdnormallink{Building a text editor}{http://wewantarock.wordpress.com/2010/01/31/building-a-text-editor-part-1/}~\cite{wewantarock}.

\newpage
\section{Resultados}
\subsection{Objetivos Alcanzados}
\begin{epigraphs}
	\qitem{Results! Why, man? I have gotten a lot of results. I know several thousand things that won't work}{Thomas A. Edison}
	\qitem{Kids, you tried your best and you failed miserably. The lesson is: ``never try''}{Homer Simpson}
\end{epigraphs}
\paragraph{}A primera vista, \hpage\ puede parecer simplemente un cuadro de texto al que se le agrega la posibilidad de interpretar expresiones \haskell.  Esta visi—n es cierta, y en s’ misma es un avance con respecto a las herramientas ya existentes pues permite intercalar en un mismo documento texto libre y expresiones \haskell.
\subparagraph{}Sin embargo, \hpage\ presenta varios atributos que generan un importante valor agregado:
\begin{itemize}
	\item Permite configurar el entorno manual o autom‡ticamente en base a un paquete \cabal
	\item Permite buscar documentaci—n sobre expresiones \haskell\ utilizando \textsl{Hayoo!}
	\item Permite al usuario editar texto mientras espera el resultado de la evaluaci—n de una expresi—n
	\item Permite visualizar y analizar expresiones que contengan errores, ``bottoms'' o que generen c‡lculos ``infinitos'' sin bloquearse ante su aparici—n y sin que ellos le impidan continuar presentando el resto de la expresi—n, mostrando as’ el resultado de la manera m‡s completa posible
	\item Permite cargar, importar y recargar m—dulos de modo de modificar el contexto de ejecuci—n sin perder las expresiones con las que el usuario estaba trabajando
	\item Permite mantener varias p‡ginas de expresiones por separado, guardarlas y reabrirlas de modo de organizar m‡s amigablemente el entorno de trabajo del usuario
\end{itemize}
\subparagraph{}Son todas estas caracter’sticas las que convierten a \hpage\ en una herramienta de gran utilidad para todo desarrollador \haskell, desde el estudiante universitario que generalmente se encuentra frente a la necesidad de ``entender''  funciones del lenguaje y as’ aprenderlo hasta el desarrollador avanzado que necesita debuggear sus aplicaciones.

\newpage
\subsection{Trabajo a Realizar}\label{secTaR}
\begin{epigraphs}
	\qitem{Inside every large program, there is a small program trying to get out}{C.A.R. Hoare}
	\qitem{I'm a man with a one-track mind, so much to do in one life-time}{Queen}
\end{epigraphs}
\paragraph{}\hpage\ es todav’a una aplicaci—n en desarrollo y de c—digo abierto.  Aœn queda mucho por hacer y por eso la hemos publicado en internet utilizando \htmladdnormallink{github}{http://github.com}~\cite{github}.  Gracias a este servicio, se encuentra habilitada \htmladdnormallink{una lista de bugs y sugerencias}{http://github.com/elbrujohalcon/hPage/issues} en constante actualizaci—n.  Entre las tareas que all’ se encuentran cabe destacar:
\begin{description}
	\item[Mejoras Visuales] La UI de \hpage\ tiene mucho por mejorar y optimizar.  Ejemplos de esto son el coloreo de c—digo y la autocompleci—n.  \textsl{wxHaskell} se encuentra en constante desarrollo y sus optimizaciones deber’an ser aprovechadas por \hpage\ cuando sea posible.
	\item[\cabal] La actual integraci—n con \cabal\ cubre lo b‡sico de la configuraci—n de paquetes, como las extensiones del lenguaje y los m—dulos, pero \cabal\ permite describir varias cosas m‡s que podr’an ser aprovechadas por \hpage\ como la ubicaci—n de librer’as y otros archivos
	\item[Auto Reload] Una caracter’stica que ser’a muy œtil agregar a \hpage\ es la recarga autom‡tica de los m—dulos modificados.  De este modo, el desarrollador no necesitar’a presionar el bot—n ``reload'' cada vez que modifica un m—dulo para que \hpage\ tome los cambios realizados.
\end{description}
\paragraph{}Por otra parte, si bien no menores, los progresos realizados por \hpage\ en cuanto a la presentaci—n de interpretaciones de expresiones al usuario son s—lo los primeros pasos en un camino en el cual todav’a queda mucho por explorar.  Siguientes pasos podr’an estar relacionados con:
\begin{description}
	\item[Visualizaciones]Actualmente, \hpage\ al interpretar expresiones puede mostrar distintos resultados dependiendo del tipo de la expresi—n.  Sin embargo, sea cual fuese el resultado, no es otra cosa que texto.  Esto es bastante completo pero hay situaciones en las que resultar’a m‡s conveniente otro modo de visualizaci—n.  Podemos encontrar ejemplos de estos casos en los modelos de visualizaci—n que propone \htmladdnormallink{Vital}{http://www.cs.kent.ac.uk/projects/vital/}~\cite{vital}, pero tambiŽn, por ejemplo, para el caso de acciones de entrada/salida, ser’a œtil contar con una consola que expusiese lo que estas acciones intentan mostrar por \textsl{stdout} o \textsl{stderr}.  Desde otro punto de vista, si comparamos a \hpage\ con el \textsl{Workspace}~\cite{insidesmalltalk, smalltalkworkspace} de \textsl{SmallTalk}~\cite{smalltalk}, podr’amos decir que hasta el momento, \hpage\ permite al usuario realizar el equivalente a \textbf{Print it!} (mostrar en modo texto el resultado de evaluar una expresi—n), pero aœn no permite realizar el equivalente a \textbf{Inspect it!} (o sea, visualizar en modo gr‡fico la estructura de un objeto).
	\item[Tipos]En su af‡n de mostrar tanta informaci—n sobre las expresiones interpretadas como sea posible, \hpage\ trata de modo particular las listas.  Pero las listas son s—lo uno de los muchos tipos que pueden ser considerados a fin de presentar su interpretaci—n de un modo particular.  Podemos tomar como ejemplo el tipo \texttt{Maybe}, el tipo \texttt{Either}, los constructores de tuplas y, por que no, los tipos con constructores complejos que requieren varios valores de los cuales quiz‡ s—lo uno genera una excepci—n y el resto pueden ser interpretados sin problemas.  Esto podr’a generalizarse creando una nueva clase, que permitiese definir, para cada tipo que la implementa, c—mo deben ser evaluadas las expresiones de ese tipo a fin de obtener toda la informaci—n posible sobre ellas m‡s all‡ de que alguno(s) de sus componentes generen excepciones o c‡lculos ``infinitos''.  \hpage\ podr’a, luego, utilizar las funciones definidas por esa clase en caso de ser posible antes de recurrir a la funci—n \texttt{show} al momento de interpretar una expresi—n.
	\item[Composici—n]Al d’a de hoy, \hpage\ evalœa las acciones de la m—nada \texttt{IO} antes de presentar su interpretaci—n y muestra de manera especial las expresiones de tipo \texttt{[a]}.   Sin embargo, esta distinci—n la hace s—lo sobre el tipo ``principal'' de la expresi—n y de manera secuencial.  En otras palabras, si una expresi—n tiene tipo \texttt{IO~[a]}, \hpage\ ejecutar‡ la acci—n, pero presentar‡ el resultado de la misma sin considerar el hecho de que se trata de una lista.  Por ejemplo, ante la expresi—n \texttt{return~[1,~undefined,~2]~::~IO~[Int]}, \hpage\ mostrar‡ como resultado \texttt{[1,} e indicar‡ que no puede evaluar el resto de la cadena. De la misma manera, ante la expresi—n \texttt{[[1], [1,undefined], [2], [2,undefined]] :: [[Int]]}, \hpage\ no tomar‡ en cuenta el hecho de que los elementos de la lista principal son tambiŽn listas a la hora de presentar cada uno de ellos por separado y, por lo tanto, mostrar‡ lo siguiente como resultado de la interpretaci—n: \texttt{[[1],~$\bot$,~[2],~$\bot$]}.  Para cumplir de mejor modo con el objetivo de presentar al usuario toda la informaci—n posible, \hpage\ deber‡ contemplar estos casos y procesarlos de manera conveniente.  Para ello puede ser de gran ayuda la clase que mencionamos en el ’tem anterior.
\end{description}
\paragraph{}Por otro lado, \hpage\ es s—lo una de las mœltiples herramientas comunes en el desarrollo de lenguajes orientados a objetos que pueden ser ``migradas'' al paradigma funcional.  \hpage\ podr’a integrarse algœn d’a en una IDE m‡s completa y con mayores capacidades, que brinde al desarrollador funcionalidades tales como:
\begin{description}
	\item[Soporte para TDD] El ambiente de desarrollo de \textsl{Smalltalk} es un gran ejemplo de este tipo de herramientas ya que permite realizar (e incluso sugiere), al momento de detectar un test que falla, las tareas necesarias para hacerlo funcionar.  Una herramienta de este tipo, combinada con el poder de QuickCheck~\cite{quickcheck} podr’a ser muy œtil a la hora de desarrollar software \haskell\ utilizando Test Driven Development~\cite{tdd}.
	\item[Refactoring~\cite{refactoring}] El proceso de mejorar el dise–o de un programa sin alterar su comportamiento es una tarea de gran valor que puede ser automatizada por herramientas tales como \htmladdnormallink{Wrangler}{http://www.cs.kent.ac.uk/projects/forse/wrangler/doc/overview-summary.html}~\cite{wrangler} para \textsl{Erlang}.  Herramientas similares pueden ser incorporadas a una IDE para \haskell\ como la que aqu’ planteamos.
	\item[Administraci—n de Paquetes] Si bien \hpage\ permite trabajar con paquetes \cabal, no hace nada por su administraci—n y mantenimiento.  Una herramienta visual que permita crearlos, administrarlos y utilizarlos ser’a de gran ayuda.  La extensi—n \htmladdnormallink{EclipseFP}{http://eclipsefp.sourceforge.net/}~\cite{eclipsefp} para \textsl{Eclipse} brinda parte de esta funcionalidad.
	\item[An‡lisis de Terminaci—n] Dentro de \hpage\ o quiz‡ dentro de esta IDE para \haskell\ que estamos planteando, podr’a tener cabida la herramienta \htmladdnormallink{AProVE}{http://verify.rwth-aachen.de/psk/papers/RTA06Haskell.ps}~\cite{giesl-automated} desarrollada por  J. Giesl, S. Swiderski, P. Schneider-Kamp y R. Thiemann.  Esta herramienta permite automatizar el chequeo de terminaci—n de reescritura de tŽrminos para expresiones \textsl{Haskell}.
	\item[Debugging] La tarea de ``debuggear'' c—digo en el paradigma funcional es singularmente diferente a la misma en el paradigma imperativo.  Sin embargo, una IDE completa para \haskell\ podr’a permitir ejecutar paso a paso, por ejemplo, las acciones de la m—nada \textbf{IO}.
\end{description}
\paragraph{}Finalmente, debemos considerar que \hpage\ ha sido dise–ado y desarrollado para \haskell, pero Žste no es el œnico lenguaje que podr’a beneficiarse con una herramienta similar.  Por ejemplo, ser’a interesante pensar en una ``traducci—n'' de \hpage\ a \textsl{Erlang}, considerando y \textbf{aprovechando} las diferencias entre ambos lenguajes.

\newpage
\section{Agradecimientos}
\paragraph{}Este proyecto nunca se podr’a haber llevado a cabo sin la ayuda de muchas personas que contribuyeron de una u otra manera a su realizaci—n.  Quienes creamos \hpage\ queremos agradecer especialmente a aquellos que nos han ayudado en la comprensi—n, \textbf{correcci—n} y manejo de \textsl{wxHaskell}: \htmladdnormallink{Arjan van IJzendoorn}{http://nl.linkedin.com/pub/arjan-van-ijzendoorn/5/ba8/480}, \htmladdnormallink{Eric Y. Kow}{mailto:eric.kow@gmail.com} y \htmladdnormallink{Jeremy O. Donoghue}{http://uk.linkedin.com/pub/jeremy-o-donoghue/4/7b/478}. TambiŽn queremos agradecer a \htmladdnormallink{Timo B. H\"ubel y Sebastian M. Schlat}{http://holumbus.fh-wedel.de/} que nos han permitido integrar \hpage\ con su herramienta \textsl{Hayoo!}.  Y no podr’amos dejar de mencionar a nuestros ``beta-testers'': \htmladdnormallink{Abram Hindle}{http://softwareprocess.es/index.cgi/SoftwareProcess.es}, \htmladdnormallink{Mariano Perez Rodriguez}{mailto:mariano.perez.rodriguez@gmail.com}, \htmladdnormallink{Gustavo Salvini}{http://twitter.com/guspatagonico}, \htmladdnormallink{Facundo Villanueva}{http://twitter.com/facuvillanueva}, \htmladdnormallink{Federico Grassi}{http://www.google.com/profiles/federico.grassi} y \htmladdnormallink{BernabŽ Panarello}{http://www.linkedin.com/pub/bernabŽ-panarello/8/512/b48}.  Por œltimo, pero no por eso menos importante, queremos agradecer a \htmladdnormallink{Dar’o Ruellan}{http://www.google.com/profiles/dario.ruellan} quien ha creado nuestra \htmladdnormallink{p‡gina web}{http://haskell.hpage.com}.
\paragraph{}Finalmente yo, \htmladdnormallink{Fernando Benavides}{http://google.com/profiles/greenmellon}, quisiera agradecer a mi mujer, Constanza Zappala, que me ha acompa–ado, ayudado y soportado durante los casi dos a–os que dur— el desarrollo de este proyecto, a Juan JosŽ Comellas, Alejandro Tolomei, Francisco de Ezcurra y toda la gente de \htmladdnormallink{Novamens S.A.}{http://www.novamens.com}, la empresa en la que trabajo, por su interŽs y contribuci—n al proyecto, a todos los profesores de \textsl{Algoritmos I} (Incluida la Caja Vengadora) y \textsl{Paradigmas de Lenguajes de Programaci—n} por introducirme en el apasionante mundo de la programaci—n funcional y especialmente en \haskell, y por supuesto, a mis profesores Daniel Gor’n y Diego Garbervetsky, que desde el primer momento creyeron en m’ y en esta idea loca de ``hacer algo parecido a las cosas que tienen los que trabajan con objetos'' con la que lleguŽ a aquella primera reuni—n.
\newpage
\bibliography{hpage}
\end{document}