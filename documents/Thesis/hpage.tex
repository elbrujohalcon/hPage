\documentclass[a4paper]{article}
\usepackage[spanish,activeacute]{babel}
\usepackage[applemac]{inputenc}
\usepackage{cite}
\usepackage{graphicx}
\usepackage[left=2cm,right=2cm]{geometry}
\usepackage{ulem} %Para tachar cosas
\usepackage{epigraph}
\usepackage{enumerate}
\usepackage{listings}
\usepackage{html}
\usepackage{booktabs}
\usepackage[colorlinks=true]{hyperref}
\bibliographystyle{plainurl}
\parindent = 0 pt
\parskip = 11 pt

\newcommand{\haskell}{\textsl{Haskell}}
\newcommand{\hpage}{\textbf{\textsl{$\lambda$Page}}}
\newcommand{\cabal}{\textsl{Cabal}}

\begin{document}

    \thispagestyle{empty}
    \begin{center}
	    {\Large Tesis de Licenciatura}\\[1em]
	    {\huge \textbf{$\lambda$Page}}\\[0.5em]
	    {\large \textit{Un bloc de notas para desarrolladores Haskell}}\\[1em]
	    \par\vspace{\stretch{1}}
	    {\large Departamento de Computación}\\[0.5em]
	    {\large Facultad de Ciencias Exactas y Naturales}\\[0.5em]
	    {\large Universidad de Buenos Aires}
	    \par\vspace{\stretch{1}}
	    \begin{figure}[h]
	        \begin{center}
	        \includegraphics[width=40mm]{pictures/logoUba}
	        \end{center}
	    \end{figure}
	    {\Large \textbf{Alumno}}\\[0.8em]
	    {\Large Fernando Benavides (LU 470/01)} \par
	    {\Large greenmellon@gmail.com} \par
	    \par\vspace{\stretch{1}}
	    {\Large \textbf{Directores}}\\[0.8em]
	    {\Large Dr. Diego Garbervetsky} \par
	    {\Large Dr. Daniel Gorín} \par
	    \par\vspace{\stretch{2}}
         {\Large \textbf{Abstract}}\\[0.5em]
    \end{center}
    El presente documento describe una herramienta para desarrolladores \haskell\ que pretende facilitar la tarea de ``debuggear'', analizar y entender código, llamada \hpage.  Con ella el usuario puede manipular ``páginas'' de texto libre que contengan expresiones \haskell, intentar interpretar estas expresiones independientemente y analizar los resultados obtenidos.
    \vspace*{\stretch{3}}
    \newpage

\tableofcontents

\newpage
\section{Estructura del Informe}
\paragraph{}El presente informe pretende presentar a \hpage, una herramienta para facilitar el trabajo de los desarrolladores \haskell.  El mismo se encuentra dividido en cuatro secciones.
\paragraph{}La primera es una sección en la que describiremos los motivos que nos llevaron a desarrollar esta herramienta, hablaremos también de otras herramientas similares y presentaremos \hpage\ de modo general, mostrando principalmente el lugar que pretendemos que ocupe dentro del mundo \haskell.
\paragraph{}En la siguiente sección intentaremos mostrar, a través de dos tutoriales, cómo utilizar \hpage\ y daremos a conocer sus virtudes y capacidades.  Para comenzar, aprenderemos cómo instalarlo, de modo que el lector pueda, una vez instalado el sistema, seguir los tutoriales paso a paso y realizar sus propias experiencias.
\subparagraph{}Luego, presentaremos un tutorial destinado al público académico que nos mostrará cómo utilizar la herramienta para ayudar al alumno a resolver ejercicios prácticos típicos de varias materias de la facultad.  Veremos allí la facilidad de trabajo que brinda \hpage\ al alumno permitiéndole descubrir paso a paso el lenguaje y sus características principales.
\subparagraph{}El segundo tutorial que presentaremos está apuntado a aquellos desarrolladores que trabajan con proyectos \haskell\ de dimensiones mayores a lo visto en el ámbito académico.  La idea de este tutorial es mostrar cómo \hpage\ puede ayudarlos a entender código existente y también a generar y testear nuevo código de manera sencilla y veloz.
\paragraph{}Una vez observado \hpage\ en funcionamiento y destacadas sus características principales, mostraremos cómo ha sido diseñado y construido.  Podremos ver los requerimientos que guiaron su diseño, la arquitectura conceptual que lo subyace y las principales decisiones de diseño e implementación que se han tomado durante su desarrollo.
\paragraph{}Finalmente presentaremos los resultados obtenidos y los contrastaremos con los objetivos planteados al inicio de este desarrollo.  Estableceremos el estado del proyecto en general, cuáles son los siguientes pasos a dar y qué otras tareas pueden llevarse a cabo a partir de ahora.

\newpage
\section{Introducción}
\subsection{Motivación}
\begin{epigraphs}
    \qitem{Motivation is what gets you started. Habit is what keeps you going}{Jim Rohn}
    \qitem{Essstamo mo-ti-va-do, nene}{El ``Bambino'' Veira}
\end{epigraphs}
\paragraph{}Actualmente estamos presenciando un importante cambio en el desarrollo de sistemas, gracias al éxito de proyectos como \htmladdnormallink{CouchDB}{http://couchdb.apache.org}~\cite{couchdb}, \htmladdnormallink{ejabberd}{http://www.ejabberd.im}~\cite{ejabberd} y el chat de \htmladdnormallink{Facebook}{http://www.facebook.com/}~\cite{facebook}, todos ellos desarrollados utilizando lenguajes del paradigma funcional.
\paragraph{}Ejemplos de éstos lenguajes de programación, como \htmladdnormallink{Haskell}{http://www.haskell.org}~\cite{haskell} o \htmladdnormallink{Erlang}{http://www.erlang.org}~\cite{erlang}, demuestran ser maduros, confiables y se presentan como una alternativa a los lenguajes tradicionales de otros paradigmas.  Sin embargo, los desarrolladores que deciden realizar el cambio de paradigma se encuentran con el problema de la escasez de ciertas herramientas que les permitan realizar su trabajo más eficientemente.  Por el contrario, éstas herramientas abundan en el desarrollo de proyectos utilizando lenguajes orientados a objetos.  En particular, nuestro foco de atención se centra sobre aquellas herramientas que permiten realizar \textsl{debugging} y \textsl{entendimiento} de código a través de \textsl{``micro-testing''}\footnote{Entiéndase \textsl{micro-testing} como la tarea de realizar tests eventuales para entender o evaluar algún aspecto de un programa} .
\paragraph{}Los desarrolladores \haskell\ cuentan actualmente con las siguientes herramientas para realizar esta tarea:
\begin{description}
	\item[\htmladdnormallink{GHCi}{http://www.haskell.org/ghc/docs/latest/html/users\_guide/ghci.html}~\cite{ghci}]
		La consola que provee \htmladdnormallink{GHC}{http://www.haskell.org/ghc}~\cite{ghc} permite a los desarrolladores evaluar expresiones, verificar su tipo o su género.  Cuenta también con un \htmladdnormallink{mecanismo de debugging}{http://www.haskell.org/ghc/docs/6.10-latest/html/users\_guide/ghci-debugger.html}~\cite{ghcdebug} integrado que permite realizar la evaluación de expresiones paso a paso.  Pese a ser la herramienta más utilizada por los desarrolladores, \textit{GHCi} tiene varias limitaciones.  En particular:
		\begin{itemize}
			\item No permite editar más de una expresión a la vez
			\item No permite intercalar expresiones con definiciones
			\item	Si bien permite utilizar definiciones, éstas se pierden al recargar módulos
			\item No es sencillo utilizar en una sesión las definiciones y/o expresiones creadas en sesiones anteriores
		\end{itemize}
	\item[\htmladdnormallink{Hugs}{http://www.haskell.org/hugs/}~\cite{hugs}]
		\textsl{Hugs98} es un intérprete pequeño y portátil de Haskell escrito en C, de modo que funciona en casi cualquier máquina. \textsl{Hugs98}, que se utiliza principalmente como un sistema de desarrollo de programas para Haskell, es extremadamente rápido para la carga de módulos y tiene la ventaja de un intérprete interactivo (en el que uno puede pasar de un módulo a otro para probar diferentes partes de un programa).  Sin embargo, al ser un intérprete, ni siquiera se acerca a igualar el rendimiento en tiempo de ejecución de, por ejemplo, programas compilados utilizando \textsl{GHC}.  Es, sin duda, el mejor sistema para los recién llegados a aprender Haskell.  Provee muchas librerías y la versión de Windows tiene una interfaz de usuario gráfica llamada \textsl{WinHugs}.
	\item[\htmladdnormallink{Hat}{http://www.haskell.org/hat}~\cite{hat}] Una herramienta para realizar seguimiento a nivel de código fuente.  A través de la generación de trazas de ejecución, \textit{Hat} ayuda a localizar errores en los programas y es útil para entender su funcionamiento.  Sin embargo, por estar basado en la generación de trazas, requiere la compilación y ejecución de un programa para poder utilizarlo y esto no siempre es cómodo para el desarrollador que puede querer simplemente analizar una expresión particular que incluso quizá no compile aún.  Además, su mantenimiento activo parece haber cesado hace más de un año y en su página se observa una importante lista de problemas conocidos y características deseadas.
\end{description}

%%------------------------------------------------------------------------------------------------------------------------------
\subsection{Trabajos Relacionados}
\begin{epigraphs}
	\qitem{If I have seen further it is only by standing on the shoulders of giants}{Isaac Newton}
	\qitem{I like work; it fascinates me. I can sit and look at it for hours}{Jerome Klapka}
\end{epigraphs}
\paragraph{}En el mundo de la programación orientada a objetos podemos encontrar herramientas como \htmladdnormallink{Java Scrapbook Pages}{http://help.eclipse.org/help33/index.jsp?topic=/org.eclipse.jdt.doc.user/reference/ref-34.htm}~\cite{javascrapbook} para \htmladdnormallink{Java}{http://www.java.com}~\cite{java}, y \htmladdnormallink{Workspace}{http://wiki.squeak.org/squeak/1934}~\cite{insidesmalltalk, smalltalkworkspace} para \htmladdnormallink{SmallTalk}{http://www.smalltalk.org}~\cite{smalltalk}.  Utilizando estos aplicativos, los desarrolladores pueden introducir pequeñas porciones de código, ejecutarlas y luego inspeccionar y analizar los resultados obtenidos.  Un concepto compartido por ambas herramientas es el de presentar ``páginas'' de texto en las que varias expresiones pueden intercalarse con partes de texto libre y permitir al desarrollador intentar evaluar sólo una porción de todo lo escrito.  Estas páginas pueden ser guardadas y luego recuperadas de modo de poder analizar nuevamente las mismas expresiones.  Además permiten crear objetos (lo que para los lenguajes funcionales equivaldría a definir expresiones) locales a la página en uso y utilizarlos en ella.
\paragraph{}Dentro del paradigma funcional, con un enfoque similar, aunque un poco más orientado a la presentación y visualización de documentos, \htmladdnormallink{Keith Hanna}{http://www.cs.kent.ac.uk/people/staff/fkh/} de la Universidad de Kent, ha desarrollado \htmladdnormallink{Vital}{http://www.cs.kent.ac.uk/projects/vital/}~\cite{vital}.  \textsl{Vital} es una implementación de un entorno de visualización de documentos para \haskell.  Pretende presentar \haskell\ de una manera apropiada para usuarios finales en áreas de aplicación como la ingeniería, las matemáticas o las finanzas.  Dentro de esta herramienta, los módulos \haskell\ son presentados como documentos en los que pueden visualizarse los valores que en ellos se definen directamente en el lugar en el que aparecen, ya sea de modo textual o gráfico (como ``vistas''). 
\paragraph{}Durante el desarrollo de \hpage\ hemos tenido que enfrentar varios desafíos relacionados principalmente con el desarrollo de interfaces visuales dentro del paradigma funcional.  Volcando el conocimiento adquirido durante ese proceso, hemos desarrollado \htmladdnormallink{wxhNotepad}{http://github.com/elbrujohalcon/wxhnotepad}~\cite{wxhnotepad} que es, ante todo, una prueba de concepto sobre cómo desarrollar editores de texto con \textsl{wxHaskell}.  Gracias a \htmladdnormallink{Jeremy O'Donoghue}{http://wewantarock.wordpress.com/about/}, \textsl{wxhNotepad} está siendo publicado como \htmladdnormallink{un tutorial}{http://wewantarock.wordpress.com/2010/01/31/building-a-text-editor-part-1/}~\cite{wewantarock} en sucesivos artículos en su blog
%%------------------------------------------------------------------------------------------------------------------------------
\subsection{\hpage}
\begin{epigraphs}
    \qitem{Ancorché lo ingegno umano faccia invenzioni varie, rispondendo con vari strumenti a un medesimo fine, mai esso trover\`a invenzione pi\`u bella, né pi\`u facile né pi\`u brieve della natura, perché nelle sue invenzioni nulla manca e nulla \`e superfluo}{Leonardo da Vinci}
    \qitem{La programación intensiva y el uso prolongado de Tetris sólo lleva a ver estructuras de orden y secuencias en la verdulería y a querer apilar los autos para formar líneas sólidas}{Darío Ruellan}
\end{epigraphs}
\paragraph{} \htmladdnormallink{\hpage}{http://haskell.hpage.com}~\cite{hpage} se presenta como una herramienta  similar al Workspace de \textit{Smalltalk}, que permite a los desarrolladores trabajar con documentos de texto libre que incluyan expresiones y definiciones.  \hpage\ es capaz de identificar las expresiones y definiciones válidas y permite al desarrollador inspeccionarlas, evaluarlas, conocer su tipo y, en el caso de expresiones de tipo, conocer su género (o \textsl{kind}).
\subparagraph{}En el espíritu de las herramientas provistas por la comunidad de desarrolladores \haskell, \hpage\ se integra con \htmladdnormallink{Cabal}{http://www.haskell.org/cabal}~\cite{cabal} y \htmladdnormallink{Hayoo!}{http://holumbus.fh-wedel.de/hayoo}~\cite{hayoo} y se encuentra ya disponible en \htmladdnormallink{HackageDB}{http://hackage.haskell.org/package/hpage}~\cite{hackage}.  \cabal\ (Common Architecture for Building Applications and Libraries) es una API distribuida con GHC que permite a un desarrollador agrupar fácilmente un conjunto de módulos para producir un paquete. Es el sistema de compilación estándar para las aplicaciones y librerías de \haskell.  \textsl{Hayoo!} es un motor de búsqueda especializado en la documentación de la API de \haskell.  El objetivo de \textsl{Hayoo!} es proporcionar una interfaz de búsqueda interactiva y fácil de usar para la documentación de varios paquetes y librerías.  Por su parte, \textsl{HackageDB} es 
un repositorio en internet de versiones de software desarrollado en \haskell, almacenadas en paquetes \cabal.
\subparagraph{}\hpage\ presenta una interfaz simple e intuitiva, desarrollada utilizando \htmladdnormallink{wxHaskell}{http://haskell.org/haskellwiki/WxHaskell}~\cite{wxhaskell}, lo que lo convierte en una aplicación multiplataforma.
\subparagraph{}Por ser una herramienta desarrollada con \haskell\ para \haskell, \hpage\ se diferencia de sus pares del mundo de objetos, al aprovechar conceptos claves como el \textsl{tipado estático}, que permite detectar errores de tipo velozmente evitando el costo de evaluar expresiones complejas, y la \textsl{evaluación perezosa}, que permite evaluar expresiones infinitas e ir exhibiendo resultados progresivamente.
\subparagraph{}A diferencia de \textsl{GHCi} que es una herramienta ``de consola'', \hpage\ permite visualizar resultados de manera más dinámica, permitiendo que errores intermedios (detectados durante la evaluación de una expresión) no impidan continuar con la misma hasta llegar a un resultado más completo.  De este modo, \hpage\ intenta brindar al usuario tanta información como le es posible obtener sobre la expresión que éste quiere interpretar, más allá de que ciertas porciones de esa expresión no puedan ser evaluadas o generen cálculos infinitos. 
\subparagraph{}\hpage\ se encuentra desarrollado utilizando \htmladdnormallink{\textsl{eprocess}}{http://hackage.haskell.org/package/eprocess}~\cite{eprocess}, una librería que facilita el manejo de ``threads'' en un estilo similar al de los procesos \textsl{Erlang}.  Utilizando esta librería, \hpage\ puede realizar tareas en paralelo y por lo tanto permitir al usuario continuar editando los documentos en los que está trabajando mientras espera que se evalúe una expresión e incluso cancelar una evaluación conservando la porción del resultado obtenida hasta ese momento.  Por otra parte, \hpage\ utiliza \textsl{eprocess} para detectar cálculos infinitos e informar sobre este hecho al usuario para que ya no siga esperando indefinidamente el resultado de la evaluación solicitada.

\newpage
\section{Descubriendo \hpage}
\subsection{Instalación}
\begin{epigraphs}
	\qitem{As a rule, software systems do not work well until they have been used, and have failed repeatedly, in real applications.}{Dave Parnas}
	\qitem{The \#1 programmer excuse for legitimately slacking off: ``My code is compiling''}{David Knutz}
\end{epigraphs}
\paragraph{}Para instalar \hpage\ en \textsl{OSX} o \textsl{Windows}, se proveen instaladores en \htmladdnormallink{el sitio web de \hpage}{http://github.com/elbrujohalcon/hPage/downloads}~\cite{hpage}, pero, como ya se ha dicho, \hpage\ se encuentra en \textsl{HackageDB} y por lo tanto el modo oficial de instalarlo es utilizando \cabal, con el siguiente comando:
\lstset{language=sh, frame=single, tabsize=2}
\begin{center}\begin{lstlisting}
$ cabal install hpage
\end{lstlisting}\end{center}
\subparagraph{}Sin embargo, para ello, previamente se deben satisfacer las siguientes dependencias:
\begin{description}
	\item[\htmladdnormallink{wxWidgets 2.8.10+}{http://www.wxwidgets.org/downloads/}~\cite{wxwidgets}] El framework de desarrollo para interfaces de usuario que utiliza \textsl{wxHaskell}.
	\item[\htmladdnormallink{Haskell Platform}{http://hackage.haskell.org/platform/}~\cite{platform}] Una distribución de \haskell\ que incluye todo lo necesario para compilar e instalar programas desarrollados en este lenguaje (de particular interés para \hpage: \textsl{GHC} y \cabal).
\end{description}
\paragraph{}El proceso de instalación de estas librerías y \hpage\ a través de \cabal\ varía según la plataforma en la que se lo desee instalar.  Las instrucciones detalladas y actualizadas se encuentran disponibles en \htmladdnormallink{la \textsl{wiki} del sitio web de \hpage}{http://wiki.github.com/elbrujohalcon/hPage/installing-page}~\cite{hwiki}.

\newpage
\subsection{Caso de Uso: Aprobando PLP con \hpage}
\begin{epigraphs}
	\qitem{How is education supposed to make me feel smarter? Besides, every time I learn something new, it pushes some old stuff out of my brain - remember when I took that home winemaking course, and I forgot how to drive?}{Homer Simpson}
\end{epigraphs}
\paragraph{}Mostraremos a continuación, a través de un ejemplo, cómo utilizar \hpage.  En este caso, hemos tomado prestada una práctica de la materia \textsl{Paradigmas de Lenguajes de Programación}~\cite{plp}.  Exhibiremos entonces, cómo un alumno podría utilizar \hpage\ en el proceso de resolver algunos de los ejercicios que allí se presentan o verificar las soluciones que propone para otros.  Seleccionamos sólo aquellos que a nuestro criterio son los más representativos a la hora de entender cómo \hpage\ ayuda al alumno.

\subsubsection{Pasos previos}
\paragraph{}Antes de comenzar a resolver los ejercicios, el alumno ejecuta \hpage\ y hace click en el botón \textsl{New}.  El programa presentará una pantalla similar a la de la Figura~\ref{tut100}.
\begin{figure}[hp]
	\begin{center}
        	\includegraphics[width=.75\textwidth]{pictures/tut1/00}
		\caption{Tutorial 1 - Previo a comenzar}
		\label{tut100}
	\end{center}
\end{figure}

\newpage
\subsubsection{Definición de Tipos y Currificación}

	\paragraph{\textsf{Ejercicio 1}}\textsf{Dado el siguiente programa, ?`Cuál es el tipo de \texttt{ys}?}
	\lstset{language=haskell, frame=single, tabsize=4}
	\begin{center}\begin{lstlisting}
		xs = [1,2,3]::[Float]
		ys = map (+) xs
	\end{lstlisting}\end{center}
	
\subparagraph{Uso de \hpage}En el caso de este ejercicio, el alumno debería deducir que el tipo de \texttt{ys} es \texttt{[Float -> Float]}.  Para chequear su deducción y asegurarse de haber obtenido el resultado deseado, puede ingresar el código provisto por la cátedra en la página de \hpage, separando ambas expresiones por un renglón en blanco (pues ese es el modo utilizado por \hpage\ para determinar qué porción de la página corresponde a cada expresión). Luego agregar la expresión de la que desea conocer el tipo (\texttt{ys}) y finalmente, presionando el botón \textsl{Interpret}, puede ver el tipo del resultado (\texttt{[Float -> Float]}) como lo muestra la Figura~\ref{tut101}.
\begin{figure}[hp]
	\begin{center}
        	\includegraphics[width=.75\textwidth]{pictures/tut1/01}
		\caption{Tutorial 1 - Ejercicio 1}
		\label{tut101}
	\end{center}
\end{figure}

\subparagraph{}Notemos que \hpage\, al ser presionado el botón \textsl{Interpret} evaluó la expresión \texttt{ys}.  Esto se debe a que, cuando no hay ninguna porción del texto de la página seleccionada, \hpage\ evalúa la expresión sobre la cual se encuentra posicionado el cursor.  Al hacerlo considera todas las definiciones que se encuentran en la página. En nuestro ejemplo, \hpage\ interpretó \texttt{ys} y para hacerlo debió recurrir tanto a su definición (\texttt{ys = map (+) xs}) como a la de \texttt{xs} (\texttt{xs = [1,2,3] :: [Float]}).

\newpage
\subsubsection{Listas por Comprensión}
\paragraph{\textsf{Ejercicio 4}}\textsf{?`Cuál es el valor de esta expresión?}
\lstset{language=haskell, frame=single, tabsize=4}
\begin{center}\begin{lstlisting}
	[ x | x <- [1..4], y <- [x..5], (x+y) `mod` 2 == 0 ]
\end{lstlisting}\end{center}
\subparagraph{Uso de \hpage}Nuevamente, en este ejercicio el alumno puede calcular el resultado manualmente y luego utilizar \hpage\ para chequear su resultado propuesto.  Para ello, ingresa el código dentro de la página, selecciona la expresión (pues de ese modo indica a \hpage\ que, al momento de interpretar, sólo quiere que sea considerada esa porción del texto de la página), y la evalúa presionando el botón \textsl{Interpret}.  \hpage\ mostrará entonces el resultado: \texttt{[1,1,1,2,2,3,3,4]} como se ve en la Figura~\ref{tut102}.
\begin{figure}[hp]
	\begin{center}
        	\includegraphics[width=.75\textwidth]{pictures/tut1/02}
		\caption{Tutorial 1 - Ejercicio 4}
		\label{tut102}
	\end{center}
\end{figure}

\paragraph{\textsf{Ejercicio 5}}\textsf{Una tripla pitagórica es una tripla $(a,b,c)$ de enteros positivos tal que $a^{2} + b^{2} = c^{2}$.  La siguiente es una definición de una lista (infinita) de triplas pitagóricas.  Explicar por qué esta definición no es muy útil.  Dar una definición mejor.}
\begin{center}\begin{lstlisting}
pitagorica :: [(Integer,Integer,Integer)] 
pitagorica = [(a,b,c) | a <- [1..], b <-[1..], c <- [1..], a^2 + b^2 == c^2] 
\end{lstlisting}\end{center}
\subparagraph{Uso de \hpage}Para resolver este ejercicio, el alumno podría comenzar por intentar evaluar la lista que se le provee, para ello escribirá su definición en una página de \hpage\ tal como se observa en la Figura~\ref{tut103} y, seleccionando las últimas tres expresiones, presionará el botón \textsl{Interpret}.  El espacio intermedio tiene la finalidad de distinguir ambas expresiones (por un lado, la declaración de tipo y, por otro, la definición de la expresión)
\begin{figure}[hp]
	\begin{center}
        	\includegraphics[width=.75\textwidth]{pictures/tut1/03}
		\caption{Tutorial 1 - Ejercicio 5 - Primer intento}
		\label{tut103}
	\end{center}
\end{figure}
\subparagraph{}El alumno podrá visualizar entonces que el resultado de la interpretación (si bien tiene un tipo válido) nunca aparece por pantalla.  Esto se debe al modo en el que se evalúan las listas por comprensión en \haskell: En este caso, teniendo tres generadores (\texttt{a}, \texttt{b} y \texttt{c}) y siguiendo la semántica de \haskell\, para generar el primer elemento de la lista, el interprete toma el primer valor posible para \texttt{a} (o sea $1$), el primer valor posible para \texttt{b} (o sea $2$) y luego itera sobre \texttt{c}, con lo que intentará verificar en cada paso de esta iteración que $1^{2} + 1^{2} = c$.  Pero $1^{2}+1^{2} = 2$ y sabemos que no existe ningún número natural que elevado al cuadrado sea $2$, por lo tanto, el interprete nunca encontrará el primer elemento de esta lista.  \hpage\ permite al alumno, pues, presionar el botón \textsl{Cancel} de modo de interrumpir la evaluación y poder continuar trabajando.
\subparagraph{}Luego de presionar el botón \textsl{Cancel}, o incluso durante el lapso en el que \hpage\ trata de evaluar la expresión, el alumno puede modificar la definición de la función \texttt{pitagorica} para cumplir con la consigna del ejercicio.  Podría, por ejemplo, reformularla como muestra la Figura~\ref{tut104} e intentar interpretarla, considerando que, dentro de los números naturales se cumple que $a > c \Rightarrow a^{2} > c^{2}$ y $b > c \Rightarrow b^{2} > c^{2}$.  \hpage\ entonces, comenzará a exhibir resultados hasta que el alumno presione el botón \textsl{Cancel}.
\begin{figure}[hp]
	\begin{center}
        	\includegraphics[width=.75\textwidth]{pictures/tut1/04}
		\caption{Tutorial 1 - Ejercicio 5 - Segundo intento}
		\label{tut104}
	\end{center}
\end{figure}
\subparagraph{}Finalmente, el alumno podría también verificar que puede obtener sólo las 5 primeras tuplas pitagóricas, definiendo la serie pitagórica y tomando sólo sus primeros 5 elementos como lo muestra la Figura~\ref{tut105}.  De este modo no necesitaría presionar el botón \textsl{Cancel}.
\begin{figure}[hp]
	\begin{center}
        	\includegraphics[width=.75\textwidth]{pictures/tut1/05}
		\caption{Tutorial 1 - Ejercicio 5 - Tercer intento}
		\label{tut105}
	\end{center}
\end{figure}

\newpage
\subsubsection{Alto Orden y Esquemas de Recursión}
\paragraph{\textsf{Ejercicio 9}}\textsf{
\renewcommand{\theenumi}{\Roman{enumi}}
\begin{enumerate}
	\item Definir la función \texttt{genLista}, que genera una lista de una cantidad dada de elementos, a partir de un elemento inicial y de una función de incremento entre los elementos de la lista.  Dicha función de incremento, dado un elemento de la lista, devuelve el elemento siguiente.
	\item Usando \texttt{genLista}, definir la función \texttt{dh}, que dado un par de números (el primero menor que el segundo), devuelve una lista de números consecutivos desde el primero hasta el segundo.
\end{enumerate}
\renewcommand{\theenumi}{\arabic{enumi}}}
\subparagraph{Uso de \hpage}En este caso, ciertamente \hpage\ no puede ayudar al alumno a \textsl{crear} las funciones que se le solicitan, pero sí puede ayudarlo a testearlas.  Supongamos pues que el alumno crea una nueva página y define en ella las funciones \texttt{genLista} y \texttt{dh} tal como se ve en la Figura~\ref{tut106}.  Luego, intenta testear su ejercicio y, tal como se ve en la Figura~\ref{tut107}, puede comprobar que sus funciones generan una recursión infinita.  Observa entonces que a \texttt{genLista} le falta un \textbf{caso base} y lo agrega, para luego volver a testear sus funciones como se ve en la Figura~\ref{tut108} y obtener así el resultado esperado.  Al igual que ya hemos visto en varios casos anteriores, debe dejar un renglón intermedio en blanco para que \hpage\ distinga las dos partes de la definición de la función.
\begin{figure}[hp]
	\begin{center}
        	\includegraphics[width=.75\textwidth]{pictures/tut1/06}
		\caption{Tutorial 1 - Ejercicio 9 - Primer Intento}
		\label{tut106}
	\end{center}
\end{figure}
\begin{figure}[hp]
	\begin{center}
        	\includegraphics[width=.75\textwidth]{pictures/tut1/07}
		\caption{Tutorial 1 - Ejercicio 9 - Recursión Infinita}
		\label{tut107}
	\end{center}
\end{figure}
\begin{figure}[hp]
	\begin{center}
        	\includegraphics[width=.75\textwidth]{pictures/tut1/08}
		\caption{Tutorial 1 - Ejercicio 9 - Segundo Intento}
		\label{tut108}
	\end{center}
\end{figure}
\subparagraph{}Cabe aclarar que lo hecho en este ejercicio no es (ni pretende tampoco) ser un completo test de las funciones creadas.  Es simplemente lo que hemos llamado \textsl{micro-testing}: El ejercicio de realizar pequeñas pruebas ``a mano'' utilizando expresiones cuyo resultado de evaluación es previsible.

\newpage
\paragraph{\textsf{Ejercicio 23}}\textsf{Definimos el siguiente tipo:}
\begin{center}\begin{lstlisting}
	data Agenda p t = Vacia | Telefonos p [t] (Agenda p t)
\end{lstlisting}\end{center}
\subparagraph{}\textsf{Este tipo modela una agenda de teléfonos.  A una agenda se le puede agregar una nueva entrada, donde se registra para una persona una lista de teléfonos.  Una misma persona puede aparecer en varias entradas.  La lista de teléfonos de una entrada puede contener repetidos.  Ejemplo:}
\begin{center}\begin{lstlisting}
miAgenda = Telefonos "Letincho" [42079999,43834567] 
           (Telefonos "Javi" [47779830] (Telefonos "Letincho" [42079999] Vacia)) 
\end{lstlisting}\end{center}
\textsf{\ldots}
\subparagraph{Uso de \hpage}El ejercicio continúa, pero en este caso, el alumno podría verse tentado a intentar evaluar \texttt{miAgenda} directamente en \hpage\ y obtendría el resultado de la Figura~\ref{tut109}.  Ésto se debe a que \hpage\ no soporta definiciones de tipos de datos directamente en el texto.  Cabe aclarar que el error obtenido no es ``prolijo'' pues viene directamente de \textsl{GHC}, cuya API (utilizada por \hpage\ a través de \textsl{hint} como se verá en la Sección~\ref{secImplement}) no provee errores tipados, sino solamente descritos en forma de texto.
\begin{figure}[hp]
	\begin{center}
        	\includegraphics[width=.75\textwidth]{pictures/tut1/09}
		\caption{Tutorial 1 - Ejercicio 23 - Primer Intento}
		\label{tut109}
	\end{center}
\end{figure}
\subparagraph{}Para conseguir el efecto deseado, el alumno puede crear un módulo (sin salir de \hpage) y guardarlo utilizando la opción \textsl{Page $\rightarrow$ Save As\ldots} o el botón \textsl{Save}) tal como se observa en la Figura~\ref{tut110}.  Luego, utilizando la opción \textsl{Haskell $\rightarrow$ Load Modules\ldots} puede cargar el módulo recién creado, seleccionar la expresión \texttt{miAgenda} y evaluarla normalmente.  Observamos el resultado de esta operación en la Figura~\ref{tut111}
\begin{figure}[hp]
	\begin{center}
        	\includegraphics[width=.75\textwidth]{pictures/tut1/10}
		\caption{Tutorial 1 - Ejercicio 23 - Crear Módulo}
		\label{tut110}
	\end{center}
\end{figure}
\begin{figure}[hp]
	\begin{center}
        	\includegraphics[width=.75\textwidth]{pictures/tut1/11}
		\caption{Tutorial 1 - Ejercicio 23 - Segundo Intento}
		\label{tut111}
	\end{center}
\end{figure}
\subparagraph{}Aprovechamos este momento para mencionar el hecho de que, si el alumno quisiese luego continuar trabajando en el módulo recién creado, podría hacerlo y, ante cada modificación, utilizar la opción \textsl{Haskell $\rightarrow$ Reload} o presionar el botón \textsl{Reload} para recargar el módulo, tomando así en contexto los cambios por él realizados.
\subparagraph{}Podemos ver, por un lado, que el resultado no ha sido mostrado, sino que sólo se informó su tipo.  Esto se debe a que el tipo \texttt{Agenda} no es instancia de la clase \texttt{Show}.  Para visualizar el resultado, el alumno podría agregar la cláusula \texttt{deriving (Show)} al tipo \texttt{Agenda}, grabar el módulo modificado, presionar el botón \textsl{Reload} y luego evaluar nuevamente \texttt{miAgenda} tal como se ve en la Figura~\ref{tut112}.
\begin{figure}[hp]
	\begin{center}
        	\includegraphics[width=.75\textwidth]{pictures/tut1/12}
		\caption{Tutorial 1 - Ejercicio 23 - Tercer Intento}
		\label{tut112}
	\end{center}
\end{figure}
\subparagraph{}Por otra parte, aprovecharemos este ejercicio simple para mostrar lo que \hpage\ permite hacer con los elementos de la lista \textsl{Modules}.  Presionando el botón derecho del mouse sobre un ítem, \hpage\ despliega un menú contextual que nos permite (entre otras opciones) ``navegar''  el módulo y conocer los elementos que exporta.  La Figura~\ref{tut113} nos muestra el ``árbol'' que se desprende de nuestro módulo \texttt{Temp}
\begin{figure}[hp]
	\begin{center}
        	\includegraphics[width=.75\textwidth]{pictures/tut1/13}
		\caption{Tutorial 1 - Navegando Módulos}
		\label{tut113}
	\end{center}
\end{figure}

\newpage
\subsubsection{Conclusiones}
\paragraph{}En este tutorial hemos demostrado un uso sencillo de \hpage\ como herramienta de \textsl{micro-testing}, permitiendo al usuario trabajar con las funciones definidas en el \texttt{Prelude} de \haskell\ además de las que él mismo desee definir localmente.
\paragraph{}Pudimos apreciar cómo \hpage\ permite definir expresiones y funciones, para luego evaluarlas de manera individual o combinada.  Pudimos ver que \hpage\ distingue unas expresiones de otras por encontrarse separadas utilizando renglones en blanco.  Vimos también cómo varía el contexto de evaluación (o sea, las expresiones que \hpage\ toma en consideración al momento de realizar una interpretación):
\begin{itemize}
	\item Si el usuario seleccionó una porción de texto, \hpage\ sólo toma en consideración las definiciones que se encuentren en la selección e interpreta la última expresión del texto seleccionado
	\item Si el usuario, en cambio, no ha seleccionado texto alguno, \hpage\ toma en consideración todas las definiciones de la página e interpreta la expresión sobre la que se encuentra posicionado por el cursor
\end{itemize}
\subparagraph{}Dichas evaluaciones pueden generar diversos resultados y hemos visto cómo se maneja \hpage\ con algunos de ellos:
\begin{itemize}
	\item Para aquellas expresiones cuyo valor no puede ser expresado en forma de texto, hemos visto cómo \hpage\ nos permite conocer su tipo.
	\item En el caso de expresiones cuyo valor es de longitud infinita, \hpage\ exhibe todo lo que el usuario desee del resultado, culminando cuando éste presiona el botón \textsl{Cancel}.
	\item Y en relación a aquellas que requieren un cálculo infinito para determinar su valor, \hpage\ muestra su tipo y permite al usuario continuar trabajando con las demás expresiones hasta que decida presionar el botón \textsl{Cancel} e interrumpir de esa manera el cálculo.
\end{itemize}
\paragraph{}Esta forma de trabajar con los resultados, combinada con la posibilidad que brinda \hpage\ de editar definiciones de manera simple y directa, para luego volver a evaluar expresiones que las usan, permite al usuario trabajar fluidamente y le da la libertad de \textsl{cometer errores}, detectarlos, corregirlos y luego continuar su trabajo.  Esta característica de \hpage\ es muy importante sobre todo para quienes se encuentran dando sus primeros pasos en el mundo de \haskell\ pues, entendemos, facilita el aprendizaje del lenguaje.
\paragraph{}También hemos visto en este tutorial cómo se puede utilizar \hpage\ para crear, cargar, modificar y recargar módulos, trabajando siempre en una única página de texto.  Ésta es otra característica de \hpage\ que facilita el trabajo ya no solamente a los estudiantes sino a todo tipo de desarrolladores \haskell.

\newpage
\subsection{Caso de Uso: Ganando al 4 en Línea con \hpage}\label{secTut2}
\begin{epigraphs}
	\qitem{We learn by example and by direct experience because there are real limits to the adequacy of verbal instruction}{Malcom Gladwell}
	\qitem{Look behind you, a Three-Headed Monkey!}{Guybrush Threepwood}
\end{epigraphs}
\paragraph{}Incluimos en este informe un segundo tutorial, apuntando esta vez a mostrar cómo \hpage\ puede ser de utilidad para un programador \haskell\ que se enfrenta a un problema complejo.  En él veremos como \hpage\ ayuda al usuario a ``entender'' código escrito por otra persona (o quizá por el mismo, algún tiempo atrás).
\subsubsection{Introducción}
\paragraph{}La historia comienza cuando nuestra amiga desarrolladora, a quien llamaremos \textsl{Fátima}\footnote{El nombre lo hemos elegido en honor a quien, hace ya casi 15 años y utilizando el sobrenombre \textsl{Perséfone}, fue la \textsl{maestra} y principal rival de 4 en Línea de Fernando Benavides en \htmladdnormallink{CyberJuegos}{http://www.cyberjuegos.com}} para darle un poco de personalidad, se encuentra con la misión de modificar una implementación de un juego de \textsl{4 en Línea}, llamada \htmladdnormallink{hfiar}{http://hackage.haskell.org/package/hfiar}~\cite{hfiar}.  Fátima tiene que adaptar el juego de modo que permita \textsl{jugar contra la computadora} pues actualmente sólo permite jugar a dos seres humanos entre sí.
\subparagraph{}Como es de suponer, Fátima no conoce al creador del juego y no puede contactarlo por lo que sus únicas herramientas, más allá de su conocimiento de \haskell\ y del juego en sí, son el código fuente de \textsl{hfiar} y \hpage.

\subsubsection{Primeros Pasos}
\paragraph{}Para comenzar, Fátima descarga el código del programa desde \textsl{HackageDB} y lo descomprime o bien clona el repositorio \textsl{Git} con el siguiente comando:
\lstset{language=sh, frame=single, tabsize=2}
\begin{center}\begin{lstlisting}
$ git clone git://github.com/elbrujohalcon/hfiar.git
\end{lstlisting}\end{center}
\begin{figure}[hp]
	\begin{center}
        	\includegraphics{pictures/tut2/00}
		\caption{Tutorial 2 - Archivos Originales}
		\label{tut200}
	\end{center}
\end{figure}
\paragraph{}Una vez hecho eso, puede observar la estructura del proyecto, tal como se ve en la Figura~\ref{tut200}.  Conociendo la estructura básica de los proyectos desarrollados en \haskell, podemos describir los archivos allí presentes de la siguiente manera:
\begin{description}
\item[hfiar.cabal] Archivo de descripción de proyecto \cabal.  Fátima puede obtener de él información general del proyecto, sus módulos, las dependencias y extensiones del lenguaje que se necesitan para compilarlo, entre otros datos.
\item[Setup.hs] Archivo \haskell\ utilizado por \cabal\ para realizar tareas especiales al momento de configurar, compilar o instalar la aplicación.  Junto con \textbf{hfiar.cabal} permite instalar el proyecto utilizando las siguientes instrucciones:
		\begin{center}\begin{lstlisting}
$ cabal configure --user
$ cabal build
$ cabal install
		\end{lstlisting}\end{center}
\item[src] Carpeta que contiene los archivos de código fuente del proyecto.  Fátima deberá analizar cada uno de ellos por separado para poder comprender su funcionamiento.
\item[LICENSE] Archivo con la licencia del proyecto, en este caso \htmladdnormallink{BSD3}{http://www.linfo.org/bsdlicense.html}~\cite{bsd}.
\item[README] En el caso de este proyecto, no se trata de algo demasiado útil, dice simplemente:
\begin{verbatim}
Four in a Row in Haskell!!
See http://hackage.haskell.org/package/hfiar
\end{verbatim}
\end{description}

\newpage
\subsubsection{Entendiendo el Proyecto}
\paragraph{}Para comenzar a entender cómo está estructurada la aplicación, Fátima abre el archivo \textbf{hfiar.cabal} (al que podemos ver en la Figura~\ref{tut201}) y observa que el proyecto se encuentra compuesto por una librería (que expone solamente al módulo \texttt{HFiaR}) y un ejecutable llamado \texttt{hfiar} que, más allá del módulo \texttt{Main}, incluye a los módulos \texttt{HFiaR.GUI} y \texttt{HFiaR.Server}.  Fátima puede ver además que, para compilar los módulos del proyecto, debe utilizar las extensiones \textbf{MultiParamTypeClasses} y \textbf{GeneralizedNewtypeDeriving}.
\begin{figure}[hp]
	\begin{center}
	\hbox{}
		\begin{center}\begin{lstlisting}
name: hfiar
version: 2.0.4
cabal-version: >=1.6
build-type: Custom
license: BSD3
license-file: LICENSE
copyright: 2010 Fernando "Brujo" Benavides
maintainer: greenmellon@gmail.com
stability: stable
homepage: http://github.com/elbrujohalcon/hfiar
package-url: http://code.haskell.org/hfiar
bug-reports: http://github.com/elbrujohalcon/hfiar/issues
synopsis: Four in a Row in Haskell!!
description: The classical game, implemented with wxHaskell
category: Game
author: Fernando "Brujo" Benavides
tested-with: GHC ==6.12.1
data-files: LICENSE README
data-dir: ""
extra-source-files: Setup.hs
extra-tmp-files:

source-repository head
    type:     git
    location: git://github.com/elbrujohalcon/hfiar.git

Library
    build-depends: base >= 4,                   base < 5,
                   mtl >=1.1.0,                 mtl < 1.2,
                   eprocess >= 1.1.2,           eprocess < 2
    extensions: MultiParamTypeClasses, GeneralizedNewtypeDeriving
    exposed-modules: HFiaR
    hs-source-dirs: src

Executable hfiar
    build-depends: wxcore >=0.12.1.4,           wxcore < 0.13,
                   wx >=0.12.1.4,               wx < 0.13
    extensions: MultiParamTypeClasses, GeneralizedNewtypeDeriving
    main-is: Main.hs
    buildable: True
    hs-source-dirs: src
    other-modules: HFiaR.GUI, HFiaR.Server
    ghc-options: -Wall
    			\end{lstlisting}\end{center}
		\caption{Tutorial 2 - hfiar.cabal}
		\label{tut201}
	\end{center}
\end{figure}
\subparagraph{}Habiendo realizado este análisis, Fátima configura el proyecto ejecutando la siguiente instrucción:
\begin{center}\begin{lstlisting}
$ cabal configure --user
\end{lstlisting}\end{center}
\subparagraph{}Sabiendo que existe una librería en el proyecto, Fátima intenta generar su documentación, ejecutando:
\begin{center}\begin{lstlisting}
$ cabal haddock
\end{lstlisting}\end{center}
\subparagraph{}En el caso de \textsl{hfiar}, ese comando genera la documentación en formato HTML, siendo su página principal \texttt{dist/doc/html/hfiar/index.html}.  Fátima encuentra allí una descripción de los componentes del módulo \texttt{HFiaR}.  Armada con estos datos, se dispone a utilizar \hpage\ para comprender cómo funcionan esos componentes.

\newpage
\subsubsection{Utilizando \hpage}
\paragraph{}Una vez abierto \hpage, Fátima puede intentar cargar el proyecto utilizando la opción \textsl{Haskell $\rightarrow$ Load Package\ldots} o el botón \textsl{Load Package}.  Eso abre una ventana en la que Fátima debe seleccionar el archivo \textbf{setup-config} generado por \cabal, tal como se ve en la Figura~\ref{tut202}.
\begin{figure}[hp]
	\begin{center}
        	\includegraphics[width=.75\textwidth]{pictures/tut2/02}
		\caption{Tutorial 2 - Cargando un proyecto \cabal}
		\label{tut202}
	\end{center}
\end{figure}
\subparagraph{}Fátima tendrá entonces a su disposición los módulos que componen la aplicación y, haciendo click con el botón derecho del mouse en ellos, podrá cargarlos, como se ve en la Figura~\ref{tut203}.  \textsl{Cargar} un módulo es la acción de poner en contexto las funciones y tipos de datos definidos en él, de modo que puedan ser utilizados dentro de las páginas actuales.  Al \textsl{cargar} un módulo, \hpage\ carga recursivamente los módulos de los que éste depende.  Todos los módulos previamente cargados, excepto los módulos del paquete, se olvidan.  Si existe código precompilado para el módulo, \hpage\ lo utiliza.  En otro caso, intenta compilar su código desde el archivo fuente.  Cabe destacar que utilizar código precompilado tiene ventajas y desventajas.  Por un lado, al estar precompilado, un módulo es cargado más velozmente y, además, quien lo haya compilado pudo haber utilizado distintas opciones de compilación, por ejemplo, con el objetivo de generar código optimizado.  Pero, por otra parte, el usuario de \hpage\ ya no tendrá acceso a las funciones internas del mismo, como lo tendría si el módulo fuese cargado desde su archivo fuente.
\begin{figure}[hp]
	\begin{center}
        	\includegraphics[width=.75\textwidth]{pictures/tut2/03}
		\caption{Tutorial 2 - Proyecto \cabal\ cargado}
		\label{tut203}
	\end{center}
\end{figure}

\newpage
\paragraph{}Recordando que el proyecto incluía una librería compuesta únicamente por el módulo \texttt{HFiaR}, nuestra amiga Fátima decide cargarlo y navegarlo utilizando el menú desplegable que nos muestra la Figura~\ref{tut204}.
\begin{figure}[hp]
	\begin{center}
        	\includegraphics[width=.75\textwidth]{pictures/tut2/04}
		\caption{Tutorial 2 - Módulo \texttt{HFiaR}}
		\label{tut204}
	\end{center}
\end{figure}
\paragraph{}Gracias a la documentación generada previamente, puede comprender que la dinámica del juego está modelada con una mónada~\cite{monads} que describe las acciones llevadas a cabo durante un partido.  El concepto de \textsl{mónada} (monad) es uno de los más difíciles de comprender para aquellos que dan sus primeros pasos en \haskell.  A los fines de este tutorial, podemos ver a las mónadas como tipos de datos que nos permiten definir acciones que generan resultados (por ejemplo, \texttt{dropIn} o \texttt{player} son acciones de la mónada \texttt{HFiaR}) y concatenarlas utilizando distintos operadores genéricos (como \texttt{$>>$}) para generar nuevas acciones más complejas (como por ejemplo, \texttt{dropIn 1 $>>$ player}, que es una acción de la mónada \texttt{HFiaR} que representa el hecho de arrojar una ficha en la columna 1 y luego verificar cuál es el jugador actual).  Estas acciones, luego pueden ser ``ejecutadas''.  En nuestro caso dicha ejecución se realiza, por ejemplo, utilizando las funciones \texttt{play} (cuyo resultado refleja el estado del partido una vez ejecutada las acción) o \texttt{eval} (cuyo resultado es el de la acción ejecutada).
\subparagraph{}Fátima verifica las funciones de la mónada \texttt{HFiaR} con las que cuenta:
\begin{description}
	\item[\texttt{dropIn}] representa el hecho de arrojar una ficha en una columna
	\item[\texttt{tryDropIn}] representa el hecho de verificar qué pasaría en el caso de realizar serie de jugadas, donde cada una de ellas corresponde a arrojar una ficha en una columna.  Es similar a \texttt{dropIn} pero sin que el juego avance
	\item[\texttt{player}] le permite conocer el jugador actual
	\item[\texttt{board}] le permite observar el tablero, que es modelado como una lista de listas de \texttt{Tile}s, o sea fichas
	\item[\texttt{result}] le permite verificar el resultado del partido, si es que el mismo ha concluido
\end{description}

\subparagraph{}Como el lector, al igual que Fátima, habrá podido ver en la Figura~\ref{tut204}, si bien las acciones que pueden definirse corresponden a la mónada \texttt{HFiaR}, dado el tipo de \texttt{play} y \texttt{eval}, las mismas pueden ser ejecutadas dentro de cualquier mónada.  Esto se debe a que la mónada está implementada utilizando la técnica de \textsl{Monad Transformers}~\cite{mtl}.  Los \textsl{Transformadores de Mónadas} (Monad Transformers) son variantes especiales de las mónadas que facilitan la combinación de mónadas.  Sus constructores de tipo tienen como parámetro un tipo monádico y producen tipos monádicos combinados.  En este tutorial, por ejemplo, las funciones \texttt{justPlay} y \texttt{justEval}, están definidas internamente utilizando el tipo transformador \texttt{HFiaRT} para ejecutar acciones de la mónada \texttt{HFiaR} dentro de la mónada \texttt{IO}.

\subparagraph{}Utilizando estas funciones, Fátima comienza a realizar su tarea de \textsl{micro-testing}.  Su primera prueba consiste en \textit{jugar} un partido en el que nada pasa, sólo para ver qué información puede obtener de él.  Coloca entonces en la página la expresión que presentamos a continuación e intenta interpretarla tal como se ve en la Figura~\ref{tut205}.  Esta expresión, aunque simple, presenta dos elementos muy utilizados por los desarrolladores \haskell: el operador \$, que equivale a encerrar entre paréntesis lo que sigue en la expresión, facilitando la lectura de la expresión en su totalidad, y la expresión \texttt{return ()}, que es la acción que representa el hecho de simplemente ``no hacer nada''.  Como toda acción debe tener un resultado, el de \texttt{return ()} es \texttt{()}, el único valor posible de tipo \texttt{Unit}.
\lstset{language=haskell, frame=single, tabsize=4}
\begin{center}\begin{lstlisting}
	justPlay $ return ()
\end{lstlisting}\end{center}
\begin{figure}[hp]
	\begin{center}
        	\includegraphics[width=.75\textwidth]{pictures/tut2/05}
		\caption{Tutorial 2 - Juego Mínimo}
		\label{tut205}
	\end{center}
\end{figure}
\subparagraph{}El resultado obtenido es el que sigue y puede interpretarse como \textsl{``el partido se encuentra en curso, es el turno del jugador que juega con fichas verdes y el tablero está vacío''}.  Cabe notar que el tipo del resultado es \texttt{IO Game}, o sea, una acción con posibles efectos colaterales de entrada/salida (dentro de la mónada \texttt{IO}) cuyo resultado es un juego (\texttt{Game}).  Sin embargo, el resultado obtenido representa simplemente a un juego.  Esto se debe a que \hpage, siguiendo el ejemplo de \textsl{GHCi}, trata de manera especial a las acciones de la mónada \texttt{IO} y, en lugar de intentar mostrarlas (cosa que, por cierto, no podría hacer) las evalúa y luego intenta presentar su resultado.
\begin{center}\begin{lstlisting}
OnCourse {gamePlayer = Green,
          gameBoard = [[],[],[],[],[],[],[]]}
\end{lstlisting}\end{center}
\newpage
\paragraph{}Usando \hpage, Fátima realiza varias otras pruebas que consignamos en la tabla que presentamos a continuación.  Con ellas puede entender el funcionamiento general de la mónada \texttt{HFiaR} y de ese modo determinar cómo su jugador de inteligencia artificial puede contemplar el desarrollo del juego, saber si el mismo ha concluido o no, si es su turno, cuál es el estado del tablero y entonces elegir cómo jugar.  Cabe notar que los resultados de tipo \texttt{Left HFiaRError} se exhiben como texto porque el desarrollador de \textsl{hfiar} ha decidido utilizar la función \texttt{show} para describir los errores en lugar de exhibir su constructor.

\lstset{language=haskell, frame=none, tabsize=4}
	\begin{table}[hp]
		\begin{center}
			\begin{tabular}{@{} cc @{}}
				\toprule
				Expresión & Resultado \\ 
				\midrule
\begin{lstlisting}
justPlay $ return ()
\end{lstlisting} &
\begin{lstlisting}
OnCourse {gamePlayer = Green,
          gameBoard = [[],[],[],[],[],[],[]]}
\end{lstlisting} \\[1.5em]

\begin{lstlisting}
justEval player
\end{lstlisting} &
\begin{lstlisting}
Right Green
\end{lstlisting} \\[1.5em]

\begin{lstlisting}
justEval $ dropIn 1 >> board
\end{lstlisting} &
\begin{lstlisting}
[[],[Green],[],[],[],[],[]]
\end{lstlisting} \\[1.5em]

\begin{lstlisting}
justEval $ dropIn 1 >> 
           dropIn 2 >> board
\end{lstlisting} &
\begin{lstlisting}
[[],[Green],[Red],[],[],[],[]]
\end{lstlisting} \\[1.5em]

\begin{lstlisting}
justEval $ dropIn 1 >> dropIn 1 >>
           dropIn 2 >> board
\end{lstlisting} &
\begin{lstlisting}
[[],[Red, Green],[Green],[],[],[],[]]
\end{lstlisting} \\[1.5em]

\begin{lstlisting}
justEval $ dropIn 7
\end{lstlisting} &
\begin{lstlisting}
Left That column doesn't exist
\end{lstlisting} \\[1.5em]

\begin{lstlisting}
justPlay $ dropIn 4 >> dropIn 1 >>
           dropIn 4 >> dropIn 1 >>
           dropIn 4 >> dropIn 1 >>
           dropIn 4
\end{lstlisting} &
\begin{lstlisting}
Ended {gameResult = WonBy Green,
       gameBoard = [[],[Red,Red,Red],
                    [],[],
                    [Green,Green,Green,Green],
                    [],[]]}
\end{lstlisting} \\[1.5em]

\begin{lstlisting}
justEval $ dropIn 4 >> dropIn 1 >>
           dropIn 4 >> dropIn 1 >>
           dropIn 4 >> dropIn 1 >>
           dropIn 4 >> result
\end{lstlisting} &
\begin{lstlisting}
Right (WonBy Green)
\end{lstlisting} \\[1.5em]

\begin{lstlisting}
justEval $ dropIn 4 >> dropIn 1 >>
           dropIn 4 >> dropIn 1 >>
           dropIn 3 >> dropIn 1 >>
           dropIn 4 >> result
\end{lstlisting} &
\begin{lstlisting}
Left Game is still on course
\end{lstlisting} \\[1.5em]

\begin{lstlisting}
justEval $ dropIn 1 >> dropIn 1 >>
           dropIn 1 >> dropIn 1 >>
           dropIn 1 >> dropIn 1 >>
           dropIn 1 >> dropIn 1
\end{lstlisting} &
\begin{lstlisting}
Left That column is full
\end{lstlisting} \\[1.5em]

			\bottomrule
		\end{tabular}
		\caption{Tutorial 2 - Pruebas realizadas en \hpage}
	\end{center}
\end{table}
\lstset{language=haskell, frame=single, tabsize=4}

\newpage
\subsubsection{Creando al \textsl{Jugador Computadora}}
\paragraph{}Con el conocimiento adquirido en el uso de \texttt{HFiaR}, Fátima decide crear la función \texttt{aiDropIn}, que se ejecutará dentro de la mónada \texttt{HFiaR}.  A continuación observamos el tipo de dicha función.  Se puede ver que el tipo de la función es similar al de \texttt{dropIn}, salvo por el hecho de no recibir el número de columna en la que el jugador desea volcar su ficha.  Eso se debe, justamente, a que será la propia función quién lo determine.
\begin{center}\begin{lstlisting}
-- | Drop a tile in a column choosen by the Artificial Inteligence
aiDropIn :: Monad m => HFiaRT m (Either HFiaRError ())
\end{lstlisting}\end{center}
\subparagraph{}Para crear \texttt{aiDropIn}, Fátima no cierra \hpage.  Por el contrario, define la función allí mismo, como podemos ver en la Figura~\ref{tut207}, componiéndola con otra función a la que denomina \texttt{bestColumn}.  Esta función se ejecutará sólo en el caso de que el partido no haya concluido.  La idea es que en ella estará el algoritmo principal de selección de columna a jugar (o sea, el verdadero motor de \textsl{inteligencia artificial}), el cual se irá perfeccionando a lo largo del tutorial.  La primera versión de \texttt{bestColumn}, con más de artificial que de inteligencia, simplemente elegirá la primer columna que no esté llena y \texttt{aiDropIn} arrojará la ficha ahí.  Recordamos que, para que \hpage\ reconozca las distintas expresiones, Fátima debe separarlas con renglones en blanco.
\begin{figure}[hp]
	\begin{center}
        	\includegraphics[width=.75\textwidth]{pictures/tut2/06}
		\caption{Tutorial 2 - \texttt{aiDropIn} versión 1}
		\label{tut207}
	\end{center}
\end{figure}

\newpage
\subparagraph{}Una vez definidas ambas funciones, Fátima decide testearlas y, para ello, no necesita más que \textsl{evaluar} un juego en el que conozca el resultado.  En particular, Fátima elije hacer jugar a la computadora contra sí misma 8 movimientos y verifica que las fichas han quedado intercaladas en la primer columna y luego el siguiente jugador ha colocado una en la segunda.
\paragraph{}El siguiente paso es agregar un poco de inteligencia a \texttt{bestColumn} de modo de que realmente sea competitivo.  Para ello, Fátima prevé que necesitará varias funciones auxiliares y una buena cantidad de código, por lo que decide convertir su página actual en un módulo al que denomina \texttt{HFiaR.AI} y graba en el lugar correspondiente entre los fuentes del proyecto, utilizando la opción \textsl{Page $\rightarrow$ Save As\ldots} o el botón \textsl{Save}.  A partir de ese momento, Fátima puede utilizar su editor \haskell\ favorito para agregar la cabecera del módulo, la importación del módulo que tenía cargado (\texttt{HFiaR}) y ``bautizar'' la expresión utilizada para testear como \texttt{testGame}.  Luego lo carga utilizando la opción \textsl{Haskell $\rightarrow$ Load Modules\ldots} y entonces, en una página nueva (creada utilizando la opción \textsl{Page $\rightarrow$ New}) escribe e interpreta la expresión \texttt{testGame}, de modo de realizar la misma prueba de la Figura~\ref{tut207}.  Es interesante notar que, pese a que el módulo creado sólo exporta la función \texttt{aiDropIn}, Fátima pudo interpretar sin problemas la función \texttt{testGame}, pues había cargado el módulo utilizando el archivo con su código fuente y eso le da acceso a todas las funciones del mismo, tanto públicas como privadas.  A partir de este momento, Fátima utiliza su editor favorito para trabajar en el módulo que ha creado y, ante cada modificación, lo recarga utilizando la opción \textsl{Haskell $\rightarrow$ Reload} o el botón \textsl{Reload}.
\subparagraph{}Para la segunda (y a los fines de este tutorial, definitiva) versión de \texttt{bestColumn}, experta jugadora de 4 en línea como es, Fátima pone un poco de criterio y decide que la función tenga en cuenta las condiciones que enumeramos a continuación:
\begin{itemize}
	\item Si poniendo la ficha en alguna columna el jugador gana el partido, se debe elegir esa columna.
	\item Si poniendo la ficha en alguna columna se impide que el jugador rival gane el partido (pues acumula 3 alineadas convenientemente) se debe elegir esa columna.
	\item En otro caso, de ser posible, debe elegirse la columna 3 (o sea, la columna central) pues para formar líneas de 4 fichas horizontales o diagonales se requiere una ficha en dicha columna
\end{itemize}

\newpage
\subparagraph{}Presentamos entonces la nueva versión de \texttt{bestColumn} y sus funciones adicionales:
\begin{center}\begin{lstlisting}
module HFiaR.AI (aiDropIn) where

import HFiaR
import Data.Maybe

bestColumn :: Monad m => HFiaRT m Int
bestColumn =
    do
        j1 <- columnWhereWins
        j2 <- columnWhereLoses
        j3 <- column3IfAvailable
        j4 <- firstAvailableColumn
        return . head $ catMaybes [j1, j2, j3, j4]

columnWhereWins, columnWhereLoses,
    column3IfAvailable, firstAvailableColumn :: Monad m => HFiaRT m (Maybe Int)

columnWhereWins = mapM (tryDropIn . (:[])) [0..6] >>= return . firstEnded

columnWhereLoses = mapM moves [0..6] >>= return . firstEnded
    where moves :: Monad m => Int -> HFiaRT m (Either HFiaRError Game)
          moves col = do
            b <- board
            let avail c = c == col || length (b!!c) == 7
            let other = length $ takeWhile avail [0..6]
            tryDropIn [other, col]

column3IfAvailable = board >>= \b -> return $ case length (b !! 3) of
                                                    7 -> Nothing
                                                    _ -> Just 3

firstAvailableColumn = board >>=
						return . Just . length . takeWhile (\c -> length c == 7)

firstEnded :: [Either HFiaRError Game] -> Maybe Int
firstEnded games = case (length $ takeWhile onCourse games) of
                        7 -> Nothing
                        g -> Just g
    where onCourse (Left _)           = False
          onCourse (Right OnCourse{}) = True
          onCourse (Right Ended{})    = False
\end{lstlisting}\end{center}
\subparagraph{} Muchas porciones del código que acabamos de exponer pueden resultar desconocidas o quizás difíciles de comprender incluso para un programador \haskell\ ya habituado a este tipo de código.  Tomemos, por ejemplo, la función \texttt{catMaybes}, utilizada en la nueva versión de \texttt{bestColumn}.  A los fines de continuar con nuestra historia y demostrar el uso de \hpage, supongamos que, si bien Fátima sabía de la existencia de esta función, no sabía en qué módulo se encontraba declarada ni recordaba exactamente su tipo.  En tal caso, lo que puede hacer es escribir el nombre de la función en la página de \hpage, seleccionarlo y utilizar la opción \textsl{Search on Hayoo!} del menú contextual que se despliega al presionar el botón derecho del mouse sobre el texto seleccionado.  En ese momento, \hpage\ le presentará la página web que se ve en la Figura~\ref{tut209}. Allí se puede observar que la función \texttt{catMaybes} se encuentra definida en el módulo \texttt{Data.Maybe} y que su tipo es \texttt{[Maybe a] -> [a]}.  Más aún, \textsl{Hayoo!} nos muestra la documentación que acompaña a la función, según la cual \textit{la función \texttt{catMaybes} toma una lista de \texttt{Maybe}s y devuelve una lista de todos los valores construidos con \texttt{Just}}.  Para probarla, Fátima puede importar el módulo \textsl{Data.Maybe} utilizando la opción \textsl{Haskell $\rightarrow$ Import modules\ldots} y realizar alguna prueba similar a la de la Figura~\ref{tut210}. 
\subparagraph{}El lector podría preguntarse en este momento por qué Fátima debió importar el módulo en lugar de cargarlo como ha hecho con los demás módulos.  Esto se debe a que el módulo \textsl{Data.Maybe} se encuentra en una librería del sistema, por lo tanto \hpage\ no tiene acceso a su código fuente ni a su versión precompilada.  \textsl{Importar} un módulo es similar a cargarlo: es la acción de poner en contexto las funciones y tipos de datos definidos y \textbf{exportados} por él, de modo que puedan ser utilizados dentro de las páginas actuales.  Al importar un módulo, el usuario no tiene acceso a las funciones y tipos de datos \textsl{privados} del mismo.
\begin{figure}[hp]
	\begin{center}
        	\includegraphics[width=.75\textwidth]{pictures/tut2/09}
		\caption{Tutorial 2 - Utilizando \textsl{Hayoo!}}
		\label{tut209}
	\end{center}
\end{figure}
\begin{figure}[hp]
	\begin{center}
        	\includegraphics[width=.75\textwidth]{pictures/tut2/10}
		\caption{Tutorial 2 - Testeando \texttt{catMaybes}}
		\label{tut210}
	\end{center}
\end{figure}

\newpage
\paragraph{} La función \texttt{testGame} ya no es suficiente para testear el funcionamiento de \texttt{aiDropin}.  Lo que hace Fátima, aprovechando la facilidad que le brinda \hpage\ para ejecutar acciones de la mónada \texttt{IO}, es crear una función auxiliar llamada \texttt{round} que, además de completar una ronda del juego (o sea, un turno jugado por el usuario y otro por la inteligencia artificial) guarda registro del estado del juego en un archivo de log.  De ese modo puede probar el comportamiento de su módulo de inteligencia artificial ante las distintas circunstancias de un partido tan extenso como ella desee.  Cabe destacar una vez más aquí que cada vez que Fátima desee realizar cambios en su módulo puede hacerlo con su editor favorito y luego presionar el botón \textsl{Reload} al volver a \hpage\ e interpretar nuevamente sus expresiones, que no han sido perdidas pues están todavía en la(s) página(s) con la(s) que está trabajando.  A modo de ejemplo, en la Figura~\ref{tut212}, presentamos el archivo resultante de la interpretación de la expresión que muestra la figura \ref{tut211}.
\begin{figure}[hp]
	\begin{center}
        	\includegraphics[width=.75\textwidth]{pictures/tut2/08}
		\caption{Tutorial 2 - \textsl{Jugando} contra \texttt{HFiaR.AI}}
		\label{tut211}
	\end{center}
\end{figure}
\begin{figure}[hp]
	\begin{center}
	\hbox{}
		\begin{lstlisting}
Human turn: Right ()
	[[],[],[],[Green],[],[],[]]
	Left Game is still on course
AI turn: Right ()
	[[],[],[],[Red,Green],[],[],[]]
	Left Game is still on course
Human turn: Right ()
	[[],[],[],[Green,Red,Green],[],[],[]]
	Left Game is still on course
AI turn: Right ()
	[[],[],[],[Red,Green,Red,Green],[],[],[]]
	Left Game is still on course
Human turn: Right ()
	[[],[Green],[],[Red,Green,Red,Green],[],[],[]]
	Left Game is still on course
AI turn: Right ()
	[[],[Green],[],[Red,Red,Green,Red,Green],[],[],[]]
	Left Game is still on course
Human turn: Right ()
	[[],[Green],[],[Green,Red,Red,Green,Red,Green],[],[],[]]
	Left Game is still on course
AI turn: Right ()
	[[],[Green],[],[Red,Green,Red,Red,Green,Red,Green],[],[],[]]
	Left Game is still on course
Human turn: Right ()
	[[],[Green],[Green],[Red,Green,Red,Red,Green,Red,Green],[],[],[]]
	Left Game is still on course
AI turn: Left That column is full
	[[],[Green],[Green],[Red,Green,Red,Red,Green,Red,Green],[],[],[]]
	Left Game is still on course
Human turn: Right ()
	[[],[Green],[Red,Green],[Red,Green,Red,Red,Green,Red,Green],[],[],[]]
	Left Game is still on course
AI turn: Right ()
	[[Green],[Green],[Red,Green],[Red,Green,Red,Red,Green,Red,Green],[],[],[]]
	Right (WonBy Green)
Human turn: Left Game ended
	[[Green],[Green],[Red,Green],[Red,Green,Red,Red,Green,Red,Green],[],[],[]]
	Right (WonBy Green)
AI turn: Left Game ended
	[[Green],[Green],[Red,Green],[Red,Green,Red,Red,Green,Red,Green],[],[],[]]
	Right (WonBy Green)
		\end{lstlisting}
		\caption{Tutorial 2 - Log del partido contra \texttt{HFiaR.AI}}
		\label{tut212}
	\end{center}
\end{figure}
\paragraph{}Resta pues modificar la interfaz gráfica para que permita al usuario jugar contra la computadora, utilizando la función \texttt{aiDropIn} en los turnos correspondientes a la máquina.  Para ello, Fátima abre el módulo \texttt{HFiaR.GUI} y realiza los cambios pertinentes.   Se trata básicamente de modificaciones de código relacionado vinculado a \textsl{wxHaskell}, para las cuales \hpage\ no es de más ayuda que en los ejemplos que hemos visto a lo largo de este tutorial.  Por ese motivo no los detallamos en este informe.  Para quien desee conocerlos puede encontrarlos en \htmladdnormallink{la página web del proyecto hfiar en github}{bihttp://github.com/elbrujohalcon/hfiar/commit/d69ab637bf32866e7e4550b6ea51cdd5fba33a90\#diff-2}~\cite{hfiar}
\paragraph{}El último paso que Fátima debe realizar es incluir su nuevo módulo en la lista de módulos de la librería \textsl{HFiaR} dentro del archivo \textbf{hfiar.cabal}.  Una vez hechas estas modificaciones, puede ejecutar los siguientes comandos y disfrutar de un partido de su juego favorito contra la computadora:
\lstset{language=sh, frame=single, tabsize=4}
\begin{center}\begin{lstlisting}
$ cabal configure --user
$ cabal build
$ cabal install
$ ~/.cabal/bin/hfiar &
\end{lstlisting}\end{center}

\newpage
\subsubsection{Conclusiones}
\paragraph{}A lo largo de este tutorial hemos podido ver cómo utilizar \hpage\ para \textsl{comprender} código \haskell\ a través de \textsl{micro-testing}.  Hemos visto también como, utilizando esa misma técnica, podemos construir paso a paso módulos \haskell\ medianamente complejos.  Pudimos ver cómo \hpage\ nos permite, al editar los módulos, recargarlos para volver a testearlos sin perder las expresiones que ya habíamos definido.
\paragraph{}Hemos podido ver cómo \hpage\ se encuentra integrado con \cabal\ para permitir cargar proyectos previamente configurados y evitar al desarrollador lidiar con el manejo de extensiones, carpetas y módulos manualmente.  Esto es una importante ventaja dado que la mayoría de los proyectos desarrollados en \haskell\ se encuentran organizados en paquetes \cabal.  Pudimos observar también cómo \hpage\ se integra con \textsl{Hayoo!}, permitiendo al desarrollador consultar sus dudas sobre la API de \haskell\ directamente dentro de la aplicación.
\paragraph{}Hemos visto cómo utilizar \hpage\ para cargar o importar módulos y hemos notado las diferencias entre estas dos acciones.  También hemos observado la forma gráfica con la que \hpage\ describe y permite navegar los módulos cargados o importados, sus funciones y sus estructuras de datos para luego utilizarlas en nuestro código.
\paragraph{}Por otra parte, hemos podido trabajar con expresiones de entrada/salida con efectos colaterales (en otras palabras, expresiones de tipo \texttt{IO a}) y hemos visto como \hpage\ las ejecuta sin problemas, tal como lo hace \textsl{GHCi}.

\newpage
\subsection{Otras Características de \hpage}
\begin{epigraphs}
	\qitem{What is best in life?}{}
	\qitem{To crush your enemies, to see them driven before you, and to hear the lamentations of their women}{Conan, the Barbarian}
	\qitem{Hot water, good dentishtry and shoft lavatory paper}{Cohen, the Barbarian}
\end{epigraphs}
\paragraph{}Los dos tutoriales que hemos presentado en este capítulo muestran muchas de las principales características de \hpage.  Sin embargo, algunas otras características han quedado sin ser expuestas.  Es nuestra intención utilizar esta sección para detallarlas, de modo que el usuario interesado pueda experimentar con ellas.

\label{secListas}\subsubsection{Listas}
\paragraph{}En el caso general, cuando el usuario desea interpretar una expresión \texttt{e}, si esta es de un tipo que es instancia de la clase \texttt{Show}, \hpage\ presenta al usuario el resultado de evaluar \texttt{show e}.  Ya hemos visto en el tutorial de la sección~\ref{secTut2} que las expresiones de tipo \texttt{IO a} son tratadas de un modo especial (son ejecutadas y se presenta al usuario el resultado de su ejecución en caso de que sea de un tipo instancia de la clase \texttt{Show}).
\subparagraph{}Otras expresiones que son tratadas de un modo particular son las listas.  Cuando el usuario decide interpretar una expresión \texttt{e :: [a]} tal que \texttt{a} es instancia de \texttt{Show}, \hpage\ no evalúa \texttt{show e}, sino que intenta evaluar cada elemento de la lista en forma independiente y así presentarlo al usuario.  De ese modo, a pesar de que uno o más de los elementos de la lista genere una excepción al intentar ser evaluado, los demás elementos pueden ser mostrados al usuario y la interpretación no se aborta.  La Figura~\ref{etc1}  nos ayudará a entender mejor este concepto.  Cabe destacar que este comportamiento contempla tanto los casos en los que los elementos de la lista generen excepciones como aquellos en los que su cálculo implique un posible cómputo infinito.  Dado que es imposible determinar cuándo un cálculo es decididamente infinito, \hpage\ utiliza un mecanismo de \textsl{timeout}: Si pasado un segundo no se ha llegado a computar un valor, se muestra al elemento del mismo modo que se muestra a aquellos que generan excepciones. 
\begin{figure}[hp]
	\begin{center}
        	\includegraphics[width=.75\textwidth]{pictures/lists01}
		\caption{Interpretación de listas}
		\label{etc1}
	\end{center}
\end{figure}
\subparagraph{}En la Figura~\ref{etc1} podemos ver que, al evaluar una lista en la que hay dos elementos que generan excepciones y uno que generaría un cálculo infinito, \hpage\ nos presenta como su interpretación el valor \texttt{[1, 2, $\bot$, $\bot$, $\bot$, 5]} y en la barra de estado nos informa que \textit{La expresión fue interpretada con errores} y podemos chequearlos \textit{clickeando con el botón derecho del mouse en cada uno de ellos}.  Al seleccionar el caracter \texttt{$\bot$} y hacer click con el botón derecho del mouse, se despliega el menú contextual que podemos apreciar en la Figura~\ref{etc2}. Al presionar la opción \textsl{Explain}, \hpage\ nos presenta un cuadro de diálogo explicando el error, como vemos en la Figura~\ref{etc3}.
\begin{figure}[hp]
	\begin{center}
        	\includegraphics[width=.75\textwidth]{pictures/lists02}
		\caption{Interpretación de listas - Explicar}
		\label{etc2}
	\end{center}
\end{figure}
\begin{figure}[hp]
	\begin{center}
        	\includegraphics[width=.75\textwidth]{pictures/lists03}
		\caption{Interpretación de listas - Explicación}
		\label{etc3}
	\end{center}
\end{figure}

\clearpage
\newpage
\subsubsection{Género}
\paragraph{}Otro caso de expresiones que son tratadas de un modo particular es el de las expresiones de tipo (como pueden ser \texttt{IO ()}, \texttt{Int} o \texttt{(Num n, Monad m) =>\ Float ->\ m [Float ->\ n]}).  En estos casos, \hpage\ entiende que el usuario al presionar el botón \textsl{Interpret} no quiere conocer el valor de la expresión sino más bien el género (o, en inglés, \textsl{kind}) del tipo.  En \haskell\ cada tipo tiene un género asociado que puede ser utilizado para asegurar que el tipo es usado de modo correcto.  Las expresiones de tipos son clasificadas según sus géneros, los cuales pueden tomar una de las siguientes formas:
\begin{itemize}
	\item El símbolo \texttt{*} representa el género de tipos asociados con datos concretos.
	\item Si $k_{1}$ y $k_{2}$ son géneros, entonces $k_{1} \rightarrow k_{2}$ es el género de de los tipos que toman un tipo con género $k_{1}$ y devuelven un tipo con género $k_{2}$
\end{itemize}
\subparagraph{}Veamos como ejemplos las expresiones de las Figuras~\ref{etc4},~\ref{etc5} y~\ref{etc6}.
\begin{figure}[hp]
	\begin{center}
        	\includegraphics[width=.75\textwidth]{pictures/kind01}
		\caption{Géneros - \texttt{IO ()}}
		\label{etc4}
	\end{center}
\end{figure}
\begin{figure}[hp]
	\begin{center}
        	\includegraphics[width=.75\textwidth]{pictures/kind02}
		\caption{Géneros - \texttt{Int}}
		\label{etc5}
	\end{center}
\end{figure}
\begin{figure}[hp]
	\begin{center}
        	\includegraphics[width=.75\textwidth]{pictures/kind03}
		\caption{Géneros - \texttt{(Num n, Monad m) =>\ Float ->\ m [Float ->\ n]}}
		\label{etc6}
	\end{center}
\end{figure}

\newpage
\subsubsection{Carga de Módulos por Nombre}
\paragraph{}A lo largo de los tutoriales de este capítulo varias veces el usuario ha debido cargar módulos y siempre lo ha hecho seleccionando el archivo con el código fuente del módulo que deseaba cargar.  \hpage\ brinda, además de esa forma, otra alternativa para la carga de módulos: cargarlos por su nombre.  Para ello, el usuario debe seleccionar la opción \textsl{Haskell $\rightarrow$ Load modules by name\ldots}.  El programa entonces le presentará un cuadro de texto donde ingresar los nombres de los módulos que desea cargar separados por espacios.  \hpage, entonces, buscará en primera instancia el código precompilado de cada módulo e intentará cargarlo junto con los módulos de los que depende.  De no ser posible, buscará el código fuente del mismo e intentará compilarlo y cargarlo.  Para encontrar el código fuente, \hpage\ intentará ubicar el archivo correspondiente al módulo en primer lugar dentro de los directorios de archivos fuentes del paquete \cabal\ (si es que hay uno cargado) y luego en el directorio en el que se esté ejecutando la aplicación.  Por ejemplo, en el caso de que no haya ningún paquete cargado y se intente cargar el módulo \textbf{Test.Server}, \hpage\ intentará cargar el archivo \textsl{./Test/Server.hs}.
\subsubsection{Configuración del Compilador}
\paragraph{}Hemos mostrado en el tutorial de la Sección~\ref{secTut2} cómo \hpage\ puede configurar su entorno y, sobre todo, las opciones necesarias para el compilador a partir de un paquete \cabal.  \hpage\ permite además al usuario modificar estas opciones a través del menú \textsl{Preferences...}.  Al seleccionar esta opción, \hpage\ presenta al usuario una ventana similar a la de la figura~\ref{etc7}.  En ella el usuario puede elegir las extensiones del lenguaje que desea habilitar, determinar las carpetas en las que el compilador puede ubicar los archivos con código fuente y aplicar opciones al compilador.
\begin{figure}[hp]
	\begin{center}
        	\includegraphics[width=.75\textwidth]{pictures/prefs}
		\caption{Opciones del Compilador}
		\label{etc7}
	\end{center}
\end{figure}

\newpage
\section{Desarrollo - ?`Cómo se hizo \hpage?}
\subsection{Arquitectura General}
\begin{epigraphs}
	\qitem{If you think good architecture is expensive, try bad architecture}{Brian Foote and Joseph Yoder}
\end{epigraphs}
\paragraph{}Las principales decisiones de arquitectura que se tomaron durante el desarrollo de \hpage\ tuvieron como motivaciones los siguientes requerimientos:
\begin{description}
\item[Conexión con GHC] \hpage\ debía conectarse con el motor de GHC a través de su API de modo de poder detectar e interpretar expresiones.  Para ello se utilizó \htmladdnormallink{hint}{http://projects.haskell.org/hint}~\cite{hint}.  \textsl{hint} es una librería hecha en \haskell\ que provee una abstracción de alto nivel sobre la API de GHC.  Esta librería nos permite acceder de modo sencillo a las funciones provistas por la API y así poder evaluar expresiones, determinar su tipo y, en caso de expresiones de tipo, su género, cargar e importar módulos, utilizar extensiones del lenguaje y opciones del compilador.  \textsl{hint} provee funciones que permiten este manejo y pueden ser ejecutadas dentro de la mónada \texttt{Interpreter}.
\item[Paralelismo] \hpage\ debía permitir al usuario editar sus páginas mientras esperaba el resultado de la evaluación de una expresión, detectar evaluaciones que podrían ser infinitas y presentar la interpretación de una expresión de manera incremental.  Todas estas tareas requieren la ejecución de acciones en paralelo.  Para simplificar estas tareas, se creó \textsl{eprocess} y se implementó un modelo de procesos utilizándolo.  En la Sección~\ref{secImplement} podremos observar en detalle cómo ha sido desarrollada esta librería.
\item[Errores Controlados] \hpage\ no debía fallar si la evaluación de una expresión fallaba.  Más aún, también debía detectar posibles evaluaciones infinitas e informar estas situaciones al usuario.  Aquí nuevamente entran en juego tanto \textsl{hint} como \textsl{eprocess}.
\item[Compatibilidad con GHCi] \hpage\ debía ser capaz de reemplazar a \textsl{GHCi} y, por lo tanto, brindar toda las funcionalidades que esta aplicación brinda.  En particular, debía:
	\begin{itemize}
		\item ser multiplataforma
		\item detectar expresiones sintácticamente inválidas
		\item identificar el tipo de cualquier expresión sintácticamente válida
		\item identificar el género de cualquier tipo sintácticamente válido
		\item interpretar expresiones de cualquier tipo, siempre que ese tipo sea instancia de la clase \textbf{Show}
		\item ejecutar e imprimir el resultado de expresiones de tipo \textbf{Show a $\Rightarrow$ IO a}
	\end{itemize}
\end{description}
\begin{figure}[hp]
	\begin{center}
        	\fbox{\includegraphics{pictures/architecture}}
		\caption{Arquitectura de \hpage}
		\label{arq1}
	\end{center}
\end{figure}
%%TODO: Modificar el dibujo:
%%		elementFiller -> elementFiller :: Process
%%		
\subparagraph{}Teniendo en cuenta estos requerimientos, la arquitectura resultante puede ser descripta con el diagrama de la Figura~\ref{arq1}.  Esta figura presenta el estado del sistema en un instante dado.  Cada bloque representa un proceso o ``thread'' en ejecución.  Es importante no confundir estos \textsl{threads} con los threads del sistema operativo.  Los ``threads'' utilizados por \hpage\ son administrados por la máquina virtual de \textsl{GHC}.  Por este motivo, en un thread de sistema operativo pueden coexistir varios \textsl{threads} \haskell.
\subparagraph{}Cada uno de estos procesos se ejecuta dentro del entorno de una mónada, la cual se encuentra identificada en la esquina superior derecha del bloque.  En el diagrama podemos identificar los siguientes componentes:
\begin{description}
	\item[UI Manager] Este es el thread que inicia el programa, genera y administra la interfaz del usuario utilizando las herramientas provistas por \textsl{wxHaskell}.  En este thread se mantiene el estado visual de la aplicación: el estado de los controles, la última búsqueda realizada, etc.
	\item[HPage Server] Este proceso, iniciado por el \textbf{UI Manager}, es el que comunica a la interfaz del usuario con la máquina virtual de \textsl{GHC}, a través del \textbf{Hint Server}.  En el caso de expresiones de tipo \textbf{IO a}, este mismo proceso se comunica con el \textbf{IO Server} para ejecutarlas y obtener su resultado o capturar sus errores.  En este proceso se mantiene el estado general de la aplicación: sus páginas, expresiones, paquetes y módulos cargados, etc.  Este proceso permite la ejecución de acciones definidas en la mónada \texttt{HPage} de manera sincrónica o asincrónica.  En el caso de acciones ejecutadas asincrónicamente, permite que las mismas sean canceladas.  En tales casos, dado que la API de \textsl{GHC} no provee un mecanismo para cancelar la acción en curso, \textbf{HPage Server} reinicia el \textbf{Hint Server} y se encarga de ``ponerlo al día'' aplicando las acciones necesarias para que se encuentre en el estado anterior a la ejecución de la última acción.
	\item[IO Server]Este proceso, iniciado por el  \textbf{HPage Server}, es el encargado de ejecutar acciones de tipo \textbf{IO a} en un entorno controlado y obtener su resultado.
	\item[Hint Server] Este proceso, iniciado por el \textbf{HPage Server}, mantiene una conexión con la máquina virtual de GHC a través de su API
	\item[Value Filler] Este proceso, iniciado por el \textbf{UI Manager} es el encargado de procesar el resultado obtenido del \textbf{HPage Server}.  Cabe recordar aquí que \haskell\ trabaja con evaluación ``lazy'', por lo cual el resultado obtenido no ha sido aún completamente procesado.  El \textbf{Value Filler} espera recibir un resultado y, al recibirlo, se encarga de evaluarlo y mostrarlo por pantalla, para ello intercambia mensajes con el \textbf{Element Filler} a fin de procesar cada porción del resultado a mostrar.  Qué constituye una \textsl{porción} depende del tipo de resultado.  Como hemos visto en la Sección \ref{secListas}, \hpage\ procesa de modo particular las listas.  En tales casos, a cada elemento de la lista se le aplica la función \texttt{show} obteniendo un \texttt{String} que es enviado al \textbf{Element Filler} a fin de procesarlo por separado.  En otros casos, la función \texttt{show} se aplica directamente a la expresión a interpretar y cada uno de los caracteres que componen la cadena es procesado por el \textbf{Element Filler}.  Explicaremos este proceso con más detalle en las Secciones~\ref{secDesign}~y~\ref{secImplement}.
	\item[Element Filler] Este proceso, iniciado por el \textbf{UI Manager} cumple una muy sencilla función: utilizando los procedimientos de envío y recepción de mensajes provistos por \textsl{eprocess}, espera recibir una lista de caracteres (para ser precisos, espera recibir una expresión de tipo \texttt{String}), para evaluarla y enviar como respuesta su valor en forma normal.
	\item[Runaway Killer] Este thread, instancia del tipo \textsl{TimerEx} provisto por \textsl{wxHaskell}, es iniciado por el \textbf{Value Filler} al momento de enviar un nuevo elemento al \textbf{Element Filler}.  El objetivo del \textbf{Runaway Killer} es el de detectar procesamiento ``posiblemente'' infinito.  Básicamente, pasado un segundo de procesamiento, reinicia el \textbf{Element Filler} e informa al \textbf{Value Filler} que lo inició que el elemento que se esperaba procesar ha demorado demasiado y podría desencadenar una evaluación infinita.
\end{description}
\paragraph{}Para poder entender el funcionamiento de los distintos procesos con un mayor detalle, presentaremos un ejemplo en el cual el usuario define la expresión \texttt{e = let loop = loop in [1, loop, 3, div 0 0] ++ [5..]} e intenta interpretarla, pero, mientras \hpage\ está presentándole los resultados, decide cancelar la interpretación.  Elegimos la expresión \texttt{e} por ser una lista infinita y además presentar algunos elementos que generan distintos tipos de excepciones.  La Figura~\ref{seq1} nos muestra el diagrama de secuencia correspondiente al ejemplo.
%%TODO: Modificar el dibujo:
%%		elementFiller -> elementFiller :: Process
%%		ahora anda como WIC!!
\begin{figure}[hp]
	\begin{center}
        	\fbox{\includegraphics[width=\textwidth]{pictures/sequence}}
		\caption{Secuencia de Evaluación de \texttt{e = let loop = loop in [1, loop, 3, div 0 0] ++ [5, ..]}}
		\label{seq1}
	\end{center}
\end{figure}
\subparagraph{}Podemos ver en el diagrama que el \textbf{HPage Server}, al detectar que la expresión a evaluar es una lista, en lugar de solicitar al \textbf{Hint Server} que evalúe la expresión original, le solicita la interpretación de la expresión \texttt{map show e}, de modo de obtener una lista de \texttt{String}s para retornar al \textbf{UI Manager}.  Luego, el \textbf{Value Filler}, al recibir una lista de valores a mostrar, intenta presentar cada uno de ellos por separado, concatenándolos del modo en que generalmente se presentan las listas en \haskell.  Cuando el usuario decide cancelar, \textbf{HPage Server} detiene el \textbf{Value Filler} y, por lo tanto, este proceso se interrumpe.
\subparagraph{}Con el objetivo de destacar otras interacciones más significativas, en el diagrama de la Figura~\ref{seq1} hemos omitido la parte del proceso que involucra al \textbf{Element Filler} y al \textbf{Runaway Killer}.  Para visualizar mejor su utilidad, la Figura~\ref{seq2} nos muestra en detalle lo que sucede cuando se intentan presentar los dos primeros elementos de la lista.  Como puede verse, al intentar mostrar la expresión \texttt{e}, \hpage\ se encontrará con una lista cuyo segundo elemento no puede computar pues requiere un cálculo infinito, en la Figura~\ref{seq2} representamos este caracter con la letra $\Omega$. Allí es donde entra en acción el \textbf{Runaway Killer} para informar esta situación al usuario.
%%TODO: Modificar el dibujo:
%%		elementFiller -> elementFiller :: Process
%%		ahora son elementos y no está más WIC
\begin{figure}[hp]
	\begin{center}
        	\fbox{\includegraphics[width=\textwidth]{pictures/sequence2}}
		\caption{Detalle de Secuencia de Evaluación de \texttt{e}}
		\label{seq2}
	\end{center}
\end{figure}

\newpage
\label{secDesign}\subsection{Diseño}
\begin{epigraphs}
	\qitem{Design and programming are human activities; forget that and all is lost}{Bjarne Stroustrup}
\end{epigraphs}
\paragraph{}Presentaremos a continuación las principales decisiones de diseño que se han tomado durante la creación de \hpage.  Todas ellas tienen como fundamento los requerimientos principales exhibidos en la sección anterior y también algunos requerimientos adicionales, como la integración con \cabal\ y \textsl{Hayoo!}.
\subsubsection{Concurrencia}
\paragraph{}Como hemos visto en la sección anterior, al momento de diseñar \hpage\ tuvimos que considerar la necesidad de paralelizar tareas, para permitir al usuario, por ejemplo, trabajar en un documento mientras el motor de \hpage\ evalúa una expresión.  También debemos considerar que estas tareas a realizar en paralelo no son totalmente independientes sino que requieren una sincronización.  Tomando la idea del modo en que está diseñado el lenguaje de programación \textsl{Erlang}, decidimos implementar el paralelismo utilizando lo que denominamos \textsl{procesos}.  Conceptualmente, los \textsl{procesos} son hilos de ejecución que se realizan en paralelo y pueden recibir o enviar mensajes.   Esta característica de mensajería entre procesos es la que permite la sincronía cuando es necesaria.  Por otra parte, a diferencia de \textsl{Erlang}, al utilizar \haskell, los mensajes enviados de un proceso a otro pueden ser mucho más complejos.  Gracias al hecho de que en \haskell\ las acciones son elementos de primer orden, un proceso puede enviar a otro directamente las acciones que desea que éste ejecute, tal como deben ser ejecutadas.  Esta es una característica esencial para reducir la complejidad de la implementación de todos nuestros procesos, en particular de aquellos que actúan como servidores (\textbf{IO Server}, \textbf{HPage Server} y \textbf{Hint Server}), como veremos luego en la Sección~\ref{secImplement}.
\subsubsection{Bottoms}\label{secBottoms}
\paragraph{}El lenguaje \haskell\ tiene una característica única: \textsl{la evaluación perezosa} o \textsl{lazy evaluation}.  Gracias a esta característica, las expresiones \haskell\ no son completamente evaluadas (reducidas a forma normal) hasta el momento en que realmente se necesita conocer su valor.  Dado que \hpage\ presenta al usuario un interprete de expresiones, es necesario que esté preparado para no sólo soportar sino también aprovechar esta característica.  En particular, dentro de \hpage\ las expresiones son reducidas a forma normal al momento de intentar mostrar el resultado de su evaluación al usuario.  En ese momento, \hpage\ distingue cuatro tipos de valores:
\begin{description}
	\item[Entrada/Salida] Expresiones cuyo valor es de tipo \texttt{IO a}, donde \texttt{a} es un tipo que es instancia de la clase \texttt{Show}.  En este caso, \hpage\ intentará ejecutar la acción, obtener su resultado y presentarlo al usuario como se verá a continuación.
	\item[Listas] Expresiones cuyo valor es de tipo \texttt{[a]} (o sea, listas con elementos de tipo \texttt{a}), donde \texttt{a} es un tipo que es instancia de la clase \texttt{Show}.  En este caso, \hpage\ intenta reducir cada elemento e ir presentándolo al usuario dentro de una lista.  Durante este proceso, pueden suceder varias cosas:
		\begin{itemize}
			\item Por supuesto, puede suceder que al evaluar un elemento se obtenga una cadena de caracteres, en cuyo caso \hpage\ simplemente presentará el resultado al usuario y continuará evaluando el resto de la lista.
			\item Puede suceder también que, intentando evaluar un elemento, se genere un cálculo ``infinito'' o una excepción.  En estos casos, \hpage\ informa la situación al usuario y aborta esa evaluación para continuar con el siguiente elemento.
			\item Otra posibilidad es que, luego de presentar un elemento, al intentar obtener el resto de la lista, \hpage\ encuentre un cálculo ``infinito''.  En estos casos, \hpage\ permite al usuario cancelar la evaluación cuando lo considere apropiado.
			\item Por último, es posible que, luego de presentar un elemento, al intentar obtener el resto de la lista, \hpage\ encuentre una excepción.  En estos casos, \hpage\ informa la situación al usuario y aborta la evaluación de la expresión.
		\end{itemize}
	\item[Expresiones ``visibles''] Expresiones cuyo tipo es instancia de la clase \texttt{Show}.  \hpage\ intenta evaluar la expresión a mostrar y, al igual que en el caso anterior, nos podemos encontrar con varios casos:
		\begin{itemize}
			\item Al igual que en el caso de las listas lo esperado es que al evaluar la expresión se obtenga una cadena de caracteres, en cuyo caso \hpage\ simplemente presentará el resultado al usuario.
			\item Puede suceder que, intentando evaluar la expresión se obtenga una cadena de caracteres de longitud infinita.  La política de \hpage\ en este caso es permitir al usuario decidir cuándo desea abortar la evaluación y mostrar la porción del resultado obtenida hasta ese momento
			\item Puede suceder también que, intentando evaluar un caracter, se genere un cálculo ``infinito'' o una excepción.  En este caso también, \hpage\ permite al usuario cancelar la evaluación cuando lo considere apropiado.
			\item Otra posibilidad es que, luego de presentar un caracter, al intentar obtener el resto de la cadena, \hpage\ encuentre un cálculo ``infinito''.  En estos casos, nuevamente \hpage\ permite al usuario cancelar la evaluación cuando lo considere apropiado.
			\item Por último, es posible que, luego de presentar un caracter, al intentar obtener el resto de la cadena, \hpage\ encuentre una excepción.  En estos casos, \hpage\ informa la situación al usuario y aborta la evaluación de la expresión.
		\end{itemize}
	\item[Expresiones no ``visibles''] Expresiones cuyo tipo no es instancia de la clase \texttt{Show}.  \hpage\, ante estas expresiones, se limita a mostrar su tipo.
\end{description}
\subparagraph{}La distinción que hace \hpage\ ante los distintos tipos de expresiones  a procesar y el comportamiento escogido al momento de mostrar el resultado de su evaluación tienen como objetivo brindar al usuario la mayor cantidad de información posible sobre la expresión que desea interpretar.  Sin ellos, el comportamiento natural de un programa como \hpage\ ante una expresión \texttt{e}, sería el de asignar el resultado de \texttt{show e} al cuadro de texto que presenta el resultado al usuario.
\subparagraph{}En el caso de las acciones de entrada/salida, \hpage\ al igual que \textsl{GHCi}, considera que el usuario no está simplemente interesado en conocer el tipo de las acciones, sino en ejecutarlas para producir (de ser preciso) ciertos efectos secundarios y obtener un resultado.  Es razonable pensar que quien construye una acción de este tipo (que no es instancia de la clase \texttt{Show}) pero que produce (al ser evaluada) un resultado de un tipo que sí lo es, está interesado en ejecutar la acción y obtener el resultado.
\subparagraph{}En otro caso, veamos con un ejemplo, qué sucedería si \hpage\ asignase directamente el resultado de \texttt{show e} al cuadro de texto.  Para nuestro ejemplo, vamos a utilizar una expresión similar a la del diagrama de secuencia de la Figura~\ref{seq2} que nos va a permitir mostrar todos los casos posibles:
\begin{center}\begin{lstlisting}
let infinite = [4..] in
	let loop = loop in
		[1, undefined, 2, div 0 0, 3, loop] ++ infinite
\end{lstlisting}\end{center}
\subparagraph{}Si el usuario quisiese interpretar la expresión \texttt{infinite} y \hpage\ intentase asignar su valor (\texttt{[4..]}) al cuadro de texto, haría falta reducir a forma normal una lista infinita, cálculo que nunca terminaría y por tanto, el usuario no vería ningún resultado en la pantalla.
\subparagraph{}Si, en su lugar, el usuario quisiese interpretar la expresión completa, el intérprete generaría una excepción \texttt{Prelude.undefined} al intentar mostrar el segundo elemento de la lista y esa excepción sería todo lo que el usuario podría saber sobre la evaluación de su expresión.
\subparagraph{}Entonces, en vez de asignarlo directamente, \hpage\ podría evaluar la expresión caracter a caracter e ir presentando cada uno de ellos al usuario a medida que los va obteniendo.  En ese caso, los caracteres correspondientes al primer elemento de la lista (\texttt{[1,}) podrían ser mostrados al usuario pero, al llegar al segundo, nuevamente el intérprete generaría la excepción y ya ningún otro elemento de la lista podría ser mostrado.  Aproximadamente de este modo es como se comportan tanto \textsl{GHCi} como \textsl{Hugs98}.
\subparagraph{}Al diseñar \hpage\ decidimos intentar dar un resultado aún más completo.  Para ello, \hpage\ puede detectar que la expresión a evaluar tiene tipo \texttt{[Int]} y, por lo tanto se trata de una lista cuyos elementos son de un tipo que es instancia de la clase \texttt{Show}.  \hpage\ \textsl{``sabe''} cómo se representan las listas y, por lo tanto, puede emular el comportamiento de \texttt{show} en esos casos.  Lo que \hpage\ puede hacer pues es intentar aplicar \texttt{show} a cada elemento por separado, mostrar (de modo análogo a como se presentan las listas) aquellos que efectivamente puedan ser evaluados y exhibir de otro modo aquellos que no.  Para estos casos, en los que por algún motivo, un elemento no puede ser mostrado, hemos elegido presentar el caracter $\bot$ y permitir al usuario, a través de un menú contextual saber por qué no se ha podido mostrar el elemento.  En nuestro ejemplo, con esta modalidad, \hpage\ presentaría al usuario una lista que comenzaría con \texttt{[1, $\bot$, 2, $\bot$, 3,} y, al llegar al sexto elemento, dado que el intérprete debería resolver un cálculo infinito para presentar el siguiente elemento, dejaría de presentar resultados y el usuario no tendría otra alternativa que presionar el botón \textsl{Cancel} para detener la ejecución.
\subparagraph{}La versión actual de \hpage\ tiene en cuenta estos casos de cálculos infinitos y, por ello, al ir evaluando elemento por elemento, verifica que ninguno de ellos requiera más de un segundo en ser calculado.  En caso de demorar más que ello, \hpage\ introducirá el caracter  $\bot$ y, por lo tanto, presentará al usuario la lista, en principio, infinita que comienza con \texttt{[1, $\bot$, 2, $\bot$, 3, $\bot$, 4, 5, 6, \ldots}
\subparagraph{}De este modo, \hpage\ intenta mostrar al usuario tanta información como sea posible sobre la expresión que se quiere interpretar.  Está claro que, si bien son probablemente los más habituales, las acciones de entrada/salida y las listas son sólo dos casos especiales de un gran conjunto de tipos de expresiones cuya interpretación puede ser presentada de modo de brindar mayor información que la que brinda la evaluación directa de \texttt{show}.  Nos explayaremos más sobre este tema y sobre cómo \hpage\ podría adaptarse para contemplar otros casos en la Sección~\ref{secTaR}.

\subsubsection{Integración}
\paragraph{}Una de las herramientas más comúnmente usadas por los desarrolladores haskell es \cabal.  En un \textsl{paquete Cabal}, el desarrollador define los módulos que componen su aplicación o librería, los lugares (carpetas) dónde encontrar el código fuente y los recursos que éstos necesitan para funcionar, junto con las extensiones que se requieren para poder compilarlos.
\subparagraph{}\hpage\ por su parte, permite al desarrollador cargar o importar módulos para poder utilizarlos al momento de evaluar expresiones.  También permite definir los lugares donde el compilador puede encontrar archivos fuentes y las extensiones que éste debe utilizar al momento de compilar los archivos encontrados.
\subparagraph{}Observando estas similitudes, una integración con \cabal\ es algo que surge de manera natural y \hpage\ lo provee.  \hpage\ permite al desarrollador cargar un paquete \cabal\ previamente configurado y de ese modo utilizar los módulos, extensiones y ubicaciones en él definidos.
\paragraph{}Otra herramienta, quizá no tan popular como \cabal, pero también muy útil es \textsl{Hayoo!}.  Conociendo esta herramienta, decidimos integrarla con \hpage\ de modo que el desarrollador pueda realizar consultas en su base de datos para obtener información sobre alguna función, tipo, módulo, clase o expresión que desee analizar.

\newpage
\subsection{Implementación}\label{secImplement}
\begin{epigraphs}
	\qitem{Nothing resolves design issues like an implementation}{J. D. Horton}
	\qitem{A child of five would understand this. Send someone to fetch a child of five}{Groucho Marx}
\end{epigraphs}

\subsubsection{eprocess}\label{secEprocess}
\paragraph{}Para la implementación de \textsl{eprocess}, nuestra librería de procesos, utilizamos varias herramientas de paralelismo y concurrencia que se encuentran muy bien descriptas en el libro \htmladdnormallink{Real World Haskell}{http://book.realworldhaskell.org/read/concurrent-and-multicore-programming.html}~\cite{realworldhaskell}.  Utilizamos \textsl{Threads} para paralelizar procesos y \textsl{Channels} y \textsl{MVars} para permitirles comunicarse.
\subparagraph{}Un \textsl{Thread} es una acción de entrada/salida que se ejecuta de manera independiente.  Para crear un \textsl{Thread}, se debe importar el módulo \texttt{Control.Concurrent} y utilizar la función \texttt{forkIO}.
\subparagraph{}Una \textsl{MVar} representa una \textit{caja para un único elemento}: puede estar llena o vacía.  Podemos poner algo en la caja, llenándola, o sacarlo, vaciándola.  Si intentamos poner algo en una \textsl{MVar} que ya está llena, nuestro \textsl{Thread} quedará bloqueado hasta que otro tome su contenido y, por ende, la vacíe.  Del mismo modo, si intentamos tomar el valor de una \textsl{MVar} que está vacía, nuestro \textsl{Thread} esperará hasta que alguien ponga un valor en ella.
\subparagraph{}Finalmente, un \textsl{Channel} es una abstracción de una vía de comunicación unidireccional o, visto de otro modo, una cola de mensajes.  Siempre se puede agregar un nuevo mensaje a un canal sin bloquear el \textsl{Thread} que escribe.  Sin embargo, si el canal está vacío, el \textsl{Thread} que intente leer se bloqueará hasta que llegue el primer valor.
\subparagraph{}Con estos elementos, definimos entonces un tipo monádico para representar a las acciones a realizarse en procesos paralelos de tipo \texttt{m}, tales que retornan expresiones de tipo \texttt{a} y pueden recibir elementos de tipo \texttt{r}:
\begin{center}\begin{lstlisting}
newtype ReceiverT r m a = RT { internalReader :: ReaderT (Handle r) m a }
    deriving (Monad, MonadIO, MonadTrans, MonadCatchIO)
\end{lstlisting}\end{center}
\subparagraph{}Individualizamos luego este tipo genérico, definiendo el tipo \texttt{Process}:
\begin{center}\begin{lstlisting}
type Process r = ReceiverT r IO
\end{lstlisting}\end{center}
\subparagraph{}Finalmente definimos las funciones que permiten la ejecución y mensajería entre procesos:
\begin{center}\begin{lstlisting}
spawn :: MonadIO m => Process r k -> m (Handle r)
kill :: MonadIO m => Handle a -> m ()
self :: Monad m => ReceiverT r m (Handle r)
sendTo :: MonadIO m => Handle a -> a -> m ()
recv :: MonadIO m => ReceiverT r m r
\end{lstlisting}\end{center}
\subparagraph{}Las funciones \texttt{spawn} y \texttt{kill} inician y detienen un proceso respectivamente.  \texttt{spawn} retorna como resultado un \texttt{Handle}, que identifica unívocamente al proceso y permite enviarle mensajes utilizando la función \texttt{sendTo}.  Cabe notar que esta función no necesita ser utilizada dentro de un \textsl{process} sino simplemente en cualquier instancia de la clase \texttt{MonadIO}.  De este modo, el \textsl{thread} que haya ejecutado \texttt{spawn} puede ejecutar \texttt{sendTo} para enviar mensajes al proceso que ha iniciado.
\subparagraph{}Luego, dentro de una instancia de \texttt{ReceiverT} se puede utilizar la función \texttt{self} para conocer el propio \texttt{Handle} y \texttt{recv} para recibir mensajes.  Cabe notar que \texttt{recv} se ejecuta de manera bloqueante, emulando el comportamiento de la función \texttt{receive} de \textsl{Erlang}.  Sin embargo, a diferencia de \textsl{Erlang}, el tipado estático de \haskell\ permite garantizar en tiempo de compilación que ningún proceso reciba un mensaje que no está esperando.   Para notar esto basta observar que en el tipo de la función \texttt{sendTo} el parámetro del tipo \texttt{Handle} que indica el tipo de mensajes que espera recibir el proceso y el tipo del mensaje a enviar deben coincidir.

\newpage
\subsubsection{Servers}
\paragraph{}Con el objetivo de separar la interacción con GHC del resto de la ejecución del sistema y de esta manera, poder capturar sus excepciones y aislarlas, hemos encapsulado la ejecución de estas acciones (correspondientes a la mónada \texttt{Interpreter}) en un proceso particular, al que denominamos \textbf{Hint Server}.  Por otra parte, con objetivos similares, decidimos aislar la ejecución de las acciones propias de \hpage\ (correspondientes a la mónada \texttt{HPage}) de las relativas a la interfaz de usuario, para lo cual creamos el proceso \textbf{HPage Server}.  A su vez, también fue necesario ejecutar acciones de la mónada \texttt{IO} en un contexto controlado, por lo que desarrollamos el proceso \textbf{IO Server}.  Gracias al uso de mónadas, al hecho de que las acciones sean objetos de primer tipo y a los mecanismos provistos por \textsl{eprocess}, pudimos construir estos servers de una manera sencilla.   Mostramos, a modo de ejemplo, el código del \textbf{IO Server}:
\begin{center}\begin{lstlisting}
module HPage.IOServer (start, stop, runIn, ServerHandle) where

import Control.Exception (try, SomeException)
import Control.Monad
import Control.Monad.Trans
import Control.Concurrent.Process

newtype ServerHandle = SH {handle :: Handle (IO ())}

start :: IO ServerHandle
start = spawn ioRunner >>= return . SH
    where ioRunner = forever $ recv >>= liftIO

runIn :: ServerHandle -> IO a -> IO (Either SomeException a)
runIn server action = runHere $ do
                                    me <- self
                                    sendTo (handle server) $ try action >>=
                                                                    sendTo me
                                    recv
stop :: ServerHandle -> IO ()
stop = kill . handle
\end{lstlisting}\end{center}
\subparagraph{}Cabe destacar la simpleza de este módulo que, con no más de 20 líneas de código es capaz de ejecutar cualquier acción dentro de la mónada \texttt{IO} en un proceso aislado y controlado.
\subparagraph{}Para entender el comportamiento de este módulo, iremos paso a paso:
\subparagraph{Imports} Al inicio del módulo se realiza la importación de los siguientes módulos auxiliares:
\begin{description}
	\item[\texttt{Control.Exception}] Se importan la función \texttt{try} para poder capturar las excepciones que se generen durante la ejecución de las acciones y el constructor \texttt{SomeException} pues es el constructor del tipo de excepción más genérico, el mismo engloba a todos los demás.  Nuestro objetivo es poder capturar cualquier excepción que se genere durante la ejecución de una acción.
	\item[\texttt{Control.Monad}] Se importa el módulo para poder utilizar las funciones \texttt{$>>$} y \texttt{$>>=$} que permitirán concatenar acciones, la función \texttt{return} para determinar explícitamente el resultado de una acción y la función \texttt{forever} que explicaremos más adelante.
	\item[\texttt{Control.Monad.Trans}] Se importa el módulo para poder combinar acciones de tipo \texttt{Process} con acciones de tipo \texttt{IO a} utilizando la función \texttt{liftIO}
	\item[\texttt{Control.Concurrent.Process}] Este es el módulo en el que se encuentran definidas las funciones de la librería \textsl{eprocess}
\end{description}
\subparagraph{ServerHandle}Luego se define el tipo \texttt{ServerHandle}, cuyas instancias representan identificadores unívocos de \textsl{IO Servers}.  El proceso que inicie un servidor obtendrá un \texttt{ServerHandle} que le permitirá comunicarse con él.
\subparagraph{start}A continuación se define la función que inicia el servidor y retorna su \texttt{ServerHandle}.  El servidor es iniciado utilizando la función \texttt{spawn} provista por \textsl{eprocess}, la cual retorna un \texttt{Handle} que es encapsulado en un \texttt{ServerHandle} utilizando su constructor \texttt{SH}.  La función \texttt{spawn} toma como primer parámetro la acción (de tipo \texttt{Process}) que se ejecutará en el nuevo proceso.  En este caso, esa acción recibe el nombre de \texttt{ioRunner} y se define utilizando la función \texttt{forever} que ejecuta, en principio, indefinidamente la acción que recibe por parámetro.  En nuestro caso, la acción a ejecutar indefinidamente es \texttt{recv $>>=$ liftIO}, la cual puede leerse como ``esperar a recibir un valor y, una vez recibido, aplicarle la función \texttt{liftIO}''.  Esta función permite ejecutar acciones de tipo \texttt{IO a} dentro del contexto de otra mónada, en este caso \texttt{Process a}.
\subparagraph{runIn} La siguiente función que aparece en el módulo es \texttt{runIn}, una función pensada para ejecutar acciones.  Esta función toma como parámetro un \texttt{ServerHandle} y una acción (de tipo \texttt{IO a}), compone una nueva acción (de tipo \texttt{IO ()} que consiste en intentar evaluar la acción recibida y luego enviar el resultado de la misma nuevamente al proceso en el que se está evaluando \texttt{runIn}), envía esta nueva acción al servidor correspondiente al \texttt{ServerHandle} recibido y se bloquea esperando el resultado.  Observemos en detalle las funciones involucradas en este proceso:
\begin{description}
	\item[\texttt{runHere}] Esta función permite ejecutar acciones de tipo \texttt{Process a} en el contexto de la mónada \texttt{IO}.
	\item[\texttt{self}] Como hemos visto en la sección~\ref{secEprocess}, esta función nos permite conocer el \texttt{Handle} del propio proceso.
	\item[\texttt{sendTo}] Utilizando esta función se envía a un proceso un mensaje, en este caso la acción modificada que se espera ejecute.
	\item[\texttt{handle}] Esta función, definida de forma implícita en el constructor del tipo \texttt{ServerHandle} nos devuelve el \texttt{Handle} del mismo, que es lo que \texttt{sendTo} necesita para ``ubicar'' al proceso al que debe enviar el mensaje.
	\item[\texttt{try}] Esta función intenta ejecutar una acción y devuelve, en caso de detectar una excepción, la expresión \texttt{Left e} donde \texttt{e} es la excepción capturada y, en caso de que la acción se ejecute correctamente, la expresión \texttt{Right a} donde \texttt{a} es el resultado de la acción.
	\item[\texttt{$>>=$}] Esta función toma una acción de algún tipo que sea instancia de la clase \texttt{Control.Monad} y una función y genera una nueva acción que consiste en evaluar la primera, luego construir un nueva acción utilizando la función con el resultado obtenido como parámetro y finalmente ejecutar esta segunda acción.  En nuestro caso, la utilizamos para que el servidor (usando \texttt{sendTo me}) envíe al proceso ejecutado con \texttt{runHere} el resultado de \texttt{try action}.
	\item[\texttt{recv}] Como hemos visto en la sección~\ref{secEprocess}, esta función bloquea al proceso en espera de recibir algún mensaje y retorna ese mensaje una vez recibido.
\end{description}
\subparagraph{stop} La última de las funciones simplemente compone las funciones \texttt{handle} (nos devuelve el \texttt{Handle} del servidor) con \texttt{kill} que, como hemos visto en la sección~\ref{secEprocess}, lo detiene.

\subsubsection{Módulos de \hpage}
\paragraph{}El módulo principal de la aplicación es el denominado \texttt{HPage.Control}.  Este módulo describe la mónada \texttt{HPage} e incluye todas las acciones que pueden realizarse en ella.  Es el encargado de mantener el estado del sistema, para lo cual hemos definido un tipo de datos llamado \texttt{Context}, que mostraremos a continuación.
\begin{center}\begin{lstlisting}
newtype Expression = Exp {exprText :: String}       
    deriving (Eq, Show)

data Page = Page { -- Display --
                   expressions :: [Expression],
                   currentExpr :: Int,
                   undoActions :: [HPage ()],
                   redoActions :: [HPage ()],
                   -- File System --
                   original :: [Expression],
                   filePath    :: Maybe FilePath
                  }
                  
data Context = Context { -- Package --
                         activePackage :: Maybe PackageIdentifier,
                         pkgModules :: [Hint.ModuleName],
                         -- Pages --
                         pages :: [Page],
                         currentPage :: Int,
                         -- GHC State --
                         loadedModules :: Set String,
                         importedModules :: Set String,
                         extraSrcDirs :: [FilePath],
                         ghcOptions :: String,
                         server :: HS.ServerHandle,
                         ioServer :: HPIO.ServerHandle,
                         -- Actions --
                         recoveryLog :: Hint.InterpreterT IO ()
                       }
\end{lstlisting}\end{center}

\subparagraph{} Los principales componentes del estado del sistema son:
\begin{description}
	\item[activePackage] El paquete \cabal\ activo, si es que se ha cargado alguno.
	\item[pages] Las páginas que el usuario está viendo.  Cabe notar que un usuario puede tener varias páginas activas a la vez, una con cada documento.
	\item[loadedModules / importedModules] Los módulos que el usuario ha cargado / importado
	\item[server] El handle del \textbf{Hint Server} que el mismo \textbf{HPage Server} inicia y mantiene
	\item[ioServer] El handle del \textbf{IO Server} que el mismo \textbf{HPage Server} inicia y mantiene
	\item[recoveryLog] El log de acciones realizadas hasta el momento, necesario al momento de detener el \textbf{Hint Server}.  Cabe destacar aquí cómo se construye este log: Se trata de una única acción de tipo \texttt{Hint.InterpreterT IO ()} que se va construyendo de manera incremental al realizar cada acción que involucre a \texttt{Hint} en la mónada \texttt{HPage}.  Cuando una acción es aplicada (o sea, al momento en que ya finalizó su ejecución -recordemos que \texttt{HPage.Control} permite ejecutar acciones de manera sincrónica o asincrónica-), se ejecuta el siguiente código para agregarla al log (donde \texttt{c} es el contexto actual, \texttt{ra} es la acción ejecutada y el resultado es el nuevo contexto actual, una vez almacenada la acción):
\begin{center}\begin{lstlisting}
c{recoveryLog  = (recoveryLog c) >> ra >> return ()}
\end{lstlisting}\end{center}
\end{description}

\subparagraph{}Nótese que el paquete \cabal, las extensiones y los módulos cargados o importados, etc. son independientes de las páginas con las que el usuario esté trabajando, por lo que el usuario por ejemplo no puede manejar dos paquetes \cabal\ a la vez.  Ésto se debe a que la API de \textsl{GHC} no permite la utilización de \textsl{multi-threading}, por lo tanto, dentro de un programa sólo puede haber una única lista de módulos cargados/importados, una única lista de extensiones, etc.
\subparagraph{}También debe notarse que mucha de la información de estado guardada en el \texttt{Context} es ``redundante'' pues se configura directamente en el \textbf{Hint Server}.  Eso se debe a que ante la necesidad de reiniciarlo, el \textbf{HPage Server} restaura su estado utilizando esos datos.
\subparagraph{}Finalmente, \texttt{recoveryLog} se utiliza para permitir al usuario cancelar acciones que intenta ejecutar de modo asincrónico.  Cada acción que se desea realizar de forma asincrónica, devuelve una \textsl{MVar} que se llenará en caso de finalizar la acción con éxito y se acumulará en el \texttt{recoveryLog}.  En caso de que el usuario decida cancelar, el \textbf{HPage Server} reiniciará el \textbf{IO Server} y el \textbf{Hint Server}, configurará a este último según los demás parámetros (ej: \texttt{ghcOptions}) y ejecutará \texttt{recoveryLog} para ``ponerlo al día''.
\subparagraph{}El estado de las páginas con las que el usuario trabaja está definido como una lista de expresiones y dos listas de acciones para permitir el uso de \textsl{undo} y \textsl{redo}.  Finalmente, si la página corresponde a un archivo en disco, \hpage\ identifica el ``path'' del mismo para poder guardarlo o recargarlo de ser necesario.
\subparagraph{}Gracias a haber separado la lógica correspondiente a la interfaz de usuario y la propia de \hpage, hemos podido desarrollar esta última utilizando la técnica de TDD (Test Driven Development) ~\cite{tdd}.  Para ello utilizamos \htmladdnormallink{QuickCheck}{http://www.cs.chalmers.se/~rjmh/QuickCheck/}~\cite{quickcheck}, una herramienta de testeo automático para programas \haskell\ que nos permitió ir desarrollando y verificando tests de manera incremental hasta alcanzar la actual definición del \textbf{HPage Server}.  Los tests desarrollados pueden ser ejecutados utilizando el siguiente comando:
\lstset{language=sh, frame=single, tabsize=2}
\begin{center}\begin{lstlisting}
$ cabal test hpage
\end{lstlisting}\end{center}
\lstset{language=haskell, frame=single, tabsize=4}

\subsubsection{UI}
\paragraph{}La interfaz gráfica de \hpage\ está desarrollada utilizando \textsl{wxHaskell}, un framework elegido por ser multi-plataforma y, gracias a estar construido sobre \textsl{wxWidgets}, presentar un ``look\&feel'' nativo en distintos entornos.  \textsl{wxHaskell} es un framework sencillo para utilizar y entender y, pese a que aún se encuentra en período de evolución, es suficientemente estable.  Sin embargo, tal como puede verse en \textsl{wxhNotepad} hemos tenido que superar varios escollos hasta lograr una UI estable e intuitiva.  A los lectores interesados en estos detalles técnicos les recomendamos los artículos escritos por Jeremy O'Donoghue en su tutorial \htmladdnormallink{Building a text editor}{http://wewantarock.wordpress.com/2010/01/31/building-a-text-editor-part-1/}~\cite{wewantarock}.

\newpage
\section{Resultados}
\subsection{Objetivos Alcanzados}
\begin{epigraphs}
	\qitem{Results! Why, man? I have gotten a lot of results. I know several thousand things that won't work}{Thomas A. Edison}
	\qitem{Kids, you tried your best and you failed miserably. The lesson is: ``never try''}{Homer Simpson}
\end{epigraphs}
\paragraph{}A primera vista, \hpage\ puede parecer simplemente un cuadro de texto al que se le agrega la posibilidad de interpretar expresiones \haskell.  Esta visión es cierta, y en sí misma es un avance con respecto a las herramientas ya existentes pues permite intercalar en un mismo documento texto libre y expresiones \haskell.
\subparagraph{}Sin embargo, \hpage\ presenta varios atributos que generan un importante valor agregado:
\begin{itemize}
	\item Permite configurar el entorno manual o automáticamente en base a un paquete \cabal
	\item Permite buscar documentación sobre expresiones \haskell\ utilizando \textsl{Hayoo!}
	\item Permite al usuario editar texto mientras espera el resultado de la evaluación de una expresión
	\item Permite visualizar y analizar expresiones que contengan errores, ``bottoms'' o que generen cálculos ``infinitos'' sin bloquearse ante su aparición y sin que ellos le impidan continuar presentando el resto de la expresión, mostrando así el resultado de la manera más completa posible
	\item Permite cargar, importar y recargar módulos de modo de modificar el contexto de ejecución sin perder las expresiones con las que el usuario estaba trabajando
	\item Permite mantener varias páginas de expresiones por separado, guardarlas y reabrirlas de modo de organizar más amigablemente el entorno de trabajo del usuario
\end{itemize}
\subparagraph{}Son todas estas características las que convierten a \hpage\ en una herramienta de gran utilidad para todo desarrollador \haskell, desde el estudiante universitario que generalmente se encuentra frente a la necesidad de ``entender''  funciones del lenguaje y así aprenderlo hasta el desarrollador avanzado que necesita debuggear sus aplicaciones.

\newpage
\subsection{Trabajo a Realizar}\label{secTaR}
\begin{epigraphs}
	\qitem{Inside every large program, there is a small program trying to get out}{C.A.R. Hoare}
	\qitem{I'm a man with a one-track mind, so much to do in one life-time}{Queen}
\end{epigraphs}
\paragraph{}\hpage\ es todavía una aplicación en desarrollo y de código abierto.  Aún queda mucho por hacer y por eso la hemos publicado en internet utilizando \htmladdnormallink{github}{http://github.com}~\cite{github}.  Gracias a este servicio, se encuentra habilitada \htmladdnormallink{una lista de bugs y sugerencias}{http://github.com/elbrujohalcon/hPage/issues} en constante actualización.  Entre las tareas que allí se encuentran cabe destacar:
\begin{description}
	\item[Mejoras Visuales] La UI de \hpage\ tiene mucho por mejorar y optimizar.  Ejemplos de esto son el coloreo de código y la autocompleción.  \textsl{wxHaskell} se encuentra en constante desarrollo y sus optimizaciones deberían ser aprovechadas por \hpage\ cuando sea posible.
	\item[\cabal] La actual integración con \cabal\ cubre lo básico de la configuración de paquetes, como las extensiones del lenguaje y los módulos, pero \cabal\ permite describir varias cosas más que podrían ser aprovechadas por \hpage\ como la ubicación de librerías y otros archivos
	\item[Auto Reload] Una característica que sería muy útil agregar a \hpage\ es la recarga automática de los módulos modificados.  De este modo, el desarrollador no necesitaría presionar el botón ``reload'' cada vez que modifica un módulo para que \hpage\ tome los cambios realizados.
\end{description}
\paragraph{}Por otra parte, si bien no menores, los progresos realizados por \hpage\ en cuanto a la presentación de interpretaciones de expresiones al usuario son sólo los primeros pasos en un camino en el cual todavía queda mucho por explorar.  Siguientes pasos podrían estar relacionados con:
\begin{description}
	\item[Visualizaciones]Actualmente, \hpage\ al interpretar expresiones puede mostrar distintos resultados dependiendo del tipo de la expresión.  Sin embargo, sea cual fuese el resultado, no es otra cosa que texto.  Esto es bastante completo pero hay situaciones en las que resultaría más conveniente otro modo de visualización.  Podemos encontrar ejemplos de estos casos en los modelos de visualización que propone \htmladdnormallink{Vital}{http://www.cs.kent.ac.uk/projects/vital/}~\cite{vital}, pero también, por ejemplo, para el caso de acciones de entrada/salida, sería útil contar con una consola que expusiese lo que estas acciones intentan mostrar por \textsl{stdout} o \textsl{stderr}.  Desde otro punto de vista, si comparamos a \hpage\ con el \textsl{Workspace}~\cite{insidesmalltalk, smalltalkworkspace} de \textsl{SmallTalk}~\cite{smalltalk}, podríamos decir que hasta el momento, \hpage\ permite al usuario realizar el equivalente a \textbf{Print it!} (mostrar en modo texto el resultado de evaluar una expresión), pero aún no permite realizar el equivalente a \textbf{Inspect it!} (o sea, visualizar en modo gráfico la estructura de un objeto).
	\item[Tipos]En su afán de mostrar tanta información sobre las expresiones interpretadas como sea posible, \hpage\ trata de modo particular las listas.  Pero las listas son sólo uno de los muchos tipos que pueden ser considerados a fin de presentar su interpretación de un modo particular.  Podemos tomar como ejemplo el tipo \texttt{Maybe}, el tipo \texttt{Either}, los constructores de tuplas y, por que no, los tipos con constructores complejos que requieren varios valores de los cuales quizá sólo uno genera una excepción y el resto pueden ser interpretados sin problemas.  Esto podría generalizarse creando una nueva clase, que permitiese definir, para cada tipo que la implementa, cómo deben ser evaluadas las expresiones de ese tipo a fin de obtener toda la información posible sobre ellas más allá de que alguno(s) de sus componentes generen excepciones o cálculos ``infinitos''.  \hpage\ podría, luego, utilizar las funciones definidas por esa clase en caso de ser posible antes de recurrir a la función \texttt{show} al momento de interpretar una expresión.
	\item[Composición]Al día de hoy, \hpage\ evalúa las acciones de la mónada \texttt{IO} antes de presentar su interpretación y muestra de manera especial las expresiones de tipo \texttt{[a]}.   Sin embargo, esta distinción la hace sólo sobre el tipo ``principal'' de la expresión y de manera secuencial.  En otras palabras, si una expresión tiene tipo \texttt{IO~[a]}, \hpage\ ejecutará la acción, pero presentará el resultado de la misma sin considerar el hecho de que se trata de una lista.  Por ejemplo, ante la expresión \texttt{return~[1,~undefined,~2]~::~IO~[Int]}, \hpage\ mostrará como resultado \texttt{[1,} e indicará que no puede evaluar el resto de la cadena. De la misma manera, ante la expresión \texttt{[[1], [1,undefined], [2], [2,undefined]] :: [[Int]]}, \hpage\ no tomará en cuenta el hecho de que los elementos de la lista principal son también listas a la hora de presentar cada uno de ellos por separado y, por lo tanto, mostrará lo siguiente como resultado de la interpretación: \texttt{[[1],~$\bot$,~[2],~$\bot$]}.  Para cumplir de mejor modo con el objetivo de presentar al usuario toda la información posible, \hpage\ deberá contemplar estos casos y procesarlos de manera conveniente.  Para ello puede ser de gran ayuda la clase que mencionamos en el ítem anterior.
\end{description}
\paragraph{}Por otro lado, \hpage\ es sólo una de las múltiples herramientas comunes en el desarrollo de lenguajes orientados a objetos que pueden ser ``migradas'' al paradigma funcional.  \hpage\ podría integrarse algún día en una IDE más completa y con mayores capacidades, que brinde al desarrollador funcionalidades tales como:
\begin{description}
	\item[Soporte para TDD] El ambiente de desarrollo de \textsl{Smalltalk} es un gran ejemplo de este tipo de herramientas ya que permite realizar (e incluso sugiere), al momento de detectar un test que falla, las tareas necesarias para hacerlo funcionar.  Una herramienta de este tipo, combinada con el poder de QuickCheck~\cite{quickcheck} podría ser muy útil a la hora de desarrollar software \haskell\ utilizando Test Driven Development~\cite{tdd}.
	\item[Refactoring~\cite{refactoring}] El proceso de mejorar el diseño de un programa sin alterar su comportamiento es una tarea de gran valor que puede ser automatizada por herramientas tales como \htmladdnormallink{Wrangler}{http://www.cs.kent.ac.uk/projects/forse/wrangler/doc/overview-summary.html}~\cite{wrangler} para \textsl{Erlang}.  Herramientas similares pueden ser incorporadas a una IDE para \haskell\ como la que aquí planteamos.
	\item[Administración de Paquetes] Si bien \hpage\ permite trabajar con paquetes \cabal, no hace nada por su administración y mantenimiento.  Una herramienta visual que permita crearlos, administrarlos y utilizarlos sería de gran ayuda.  La extensión \htmladdnormallink{EclipseFP}{http://eclipsefp.sourceforge.net/}~\cite{eclipsefp} para \textsl{Eclipse} brinda parte de esta funcionalidad.
	\item[Análisis de Terminación] Dentro de \hpage\ o quizá dentro de esta IDE para \haskell\ que estamos planteando, podría tener cabida la herramienta \htmladdnormallink{AProVE}{http://verify.rwth-aachen.de/psk/papers/RTA06Haskell.ps}~\cite{giesl-automated} desarrollada por  J. Giesl, S. Swiderski, P. Schneider-Kamp y R. Thiemann.  Esta herramienta permite automatizar el chequeo de terminación de reescritura de términos para expresiones \textsl{Haskell}.
	\item[Debugging] La tarea de ``debuggear'' código en el paradigma funcional es singularmente diferente a la misma en el paradigma imperativo.  Sin embargo, una IDE completa para \haskell\ podría permitir ejecutar paso a paso, por ejemplo, las acciones de la mónada \textbf{IO}.
\end{description}
\paragraph{}Finalmente, debemos considerar que \hpage\ ha sido diseñado y desarrollado para \haskell, pero éste no es el único lenguaje que podría beneficiarse con una herramienta similar.  Por ejemplo, sería interesante pensar en una ``traducción'' de \hpage\ a \textsl{Erlang}, considerando y \textbf{aprovechando} las diferencias entre ambos lenguajes.

\newpage
\section{Agradecimientos}
\paragraph{}Este proyecto nunca se podría haber llevado a cabo sin la ayuda de muchas personas que contribuyeron de una u otra manera a su realización.  Quienes creamos \hpage\ queremos agradecer especialmente a aquellos que nos han ayudado en la comprensión, \textbf{corrección} y manejo de \textsl{wxHaskell}: \htmladdnormallink{Arjan van IJzendoorn}{http://nl.linkedin.com/pub/arjan-van-ijzendoorn/5/ba8/480}, \htmladdnormallink{Eric Y. Kow}{mailto:eric.kow@gmail.com} y \htmladdnormallink{Jeremy O. Donoghue}{http://uk.linkedin.com/pub/jeremy-o-donoghue/4/7b/478}. También queremos agradecer a \htmladdnormallink{Timo B. H\"ubel y Sebastian M. Schlat}{http://holumbus.fh-wedel.de/} que nos han permitido integrar \hpage\ con su herramienta \textsl{Hayoo!}.  Y no podríamos dejar de mencionar a nuestros ``beta-testers'': \htmladdnormallink{Abram Hindle}{http://softwareprocess.es/index.cgi/SoftwareProcess.es}, \htmladdnormallink{Mariano Perez Rodriguez}{mailto:mariano.perez.rodriguez@gmail.com}, \htmladdnormallink{Gustavo Salvini}{http://twitter.com/guspatagonico}, \htmladdnormallink{Facundo Villanueva}{http://twitter.com/facuvillanueva}, \htmladdnormallink{Federico Grassi}{http://www.google.com/profiles/federico.grassi} y \htmladdnormallink{Bernabé Panarello}{http://www.linkedin.com/pub/bernabé-panarello/8/512/b48}.  Por último, pero no por eso menos importante, queremos agradecer a \htmladdnormallink{Darío Ruellan}{http://www.google.com/profiles/dario.ruellan} quien ha creado nuestra \htmladdnormallink{página web}{http://haskell.hpage.com}.
\paragraph{}Finalmente yo, \htmladdnormallink{Fernando Benavides}{http://google.com/profiles/greenmellon}, quisiera agradecer a mi mujer, Constanza Zappala, que me ha acompañado, ayudado y soportado durante los casi dos años que duró el desarrollo de este proyecto, a Juan José Comellas, Alejandro Tolomei, Francisco de Ezcurra y toda la gente de \htmladdnormallink{Novamens S.A.}{http://www.novamens.com}, la empresa en la que trabajo, por su interés y contribución al proyecto, a todos los profesores de \textsl{Algoritmos I} (Incluida la Caja Vengadora) y \textsl{Paradigmas de Lenguajes de Programación} por introducirme en el apasionante mundo de la programación funcional y especialmente en \haskell, y por supuesto, a mis profesores Daniel Gorín y Diego Garbervetsky, que desde el primer momento creyeron en mí y en esta idea loca de ``hacer algo parecido a las cosas que tienen los que trabajan con objetos'' con la que llegué a aquella primera reunión.
\newpage
\bibliography{hpage}
\end{document}